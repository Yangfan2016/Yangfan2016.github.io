[{"title":"Javascript 继承","date":"2018-09-06T09:19:54.000Z","path":"2018/09/06/Javascript-类与继承/","text":"继承构造函数继承123456789101112131415function Parent() &#123; this.name='parent';&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; Parent.call(this);&#125;let c=new Child();c.name; // 'parent'c.run(); // undefined 缺点 无法继承父类原型上的方法 原型链实现继承1234567891011121314151617181920212223242526function Parent() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"];&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; &#125;Child.prototype=new Parent();Child.prototype.constructor=Child; var c1=new Child();var c2=new Child();c1.colors; // ['red','yellow']c2.colors; // ['red','yellow']c1.colors.push('green');c1.colors; // ['red','yellow','green']c2.colors; // ['red','yellow','green'] 缺点 子类共用一个父类的实例，造成数据污染 创建子类实例时，无法向父类构造函数传参 组合式继承123456789101112131415161718192021222324252627function Parent() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"]; console.log(\"I've executed\");&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; Parent.call(this);&#125;Child.prototype=new Parent();Child.prototype.constructor=Child;var c1=new Child(); // \"I've executed\" \"I've executed\"var c2=new Child(); // \"I've executed\" \"I've executed\"c1.colors; // ['red,yellow']c2.colors; // ['red,yellow']c1.colors.push('green');c1.colors; // ['red,yellow','green']c2.colors; // ['red,yellow'] 缺点 每新建一个子类都会调用两次父类构造器 寄生组合式继承123456789101112131415161718function Parent() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"];&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; Parent.call(this);&#125;function Super() &#123;/* noop */&#125;Super.prototype=Parent.prototype;Child.prototype=new Super();Child.prototype.constructor=Child; 特点 完美实现继承 利用寄生函数实现父类构造函数只执行一次，将原型上的方法挂载到寄生函数上，最后将寄生函数的实例作为子类的原型对象 ES6 继承1234567891011121314151617class Parent &#123; constructor() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"]; &#125; run() &#123; console.log('We can run'); &#125;&#125;class Child extends Parent&#123; constructor() &#123; super(); this.name='child'; &#125;&#125; 特点 简单明了 只是一种语法糖而已 下面是babel将ES6转成ES5继承的实现 Babel 编译后的ES5代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889\"use strict\";// 创建类var _createClass = function() &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\"in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function(Constructor, protoProps, staticProps) &#123; // 定义原型对象的属性、方法 if (protoProps) defineProperties(Constructor.prototype, protoProps); // 定义类的静态属性、方法 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125; ;&#125;();// 确保子类初始化时调用superfunction _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); &#125; return call &amp;&amp; (typeof call === \"object\" || typeof call === \"function\") ? call : self;&#125;// 继承function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); &#125; // 利用 Object.crete 创建了一个父类原型对象的新实例，并且修正了构造器指向 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); // 将子类原型链链到父类上 if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;// 安全检测，确保用 'new' 操作的构造函数function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Parent = function() &#123; function Parent() &#123; _classCallCheck(this, Parent); this.name = 'parent'; this.colors = [\"red\", \"yellow\"]; &#125; _createClass(Parent, [&#123; key: \"run\", value: function run() &#123; console.log('We can run'); &#125; &#125;]); return Parent;&#125;();var Child = function(_Parent) &#123; _inherits(Child, _Parent); function Child() &#123; _classCallCheck(this, Child); var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this)); _this.name = 'child'; return _this; &#125; return Child;&#125;(Parent);","tags":[]},{"title":"十大经典排序算法-JavaScript篇","date":"2018-08-13T07:28:20.000Z","path":"2018/08/13/十大经典排序算法-JavaScript篇/","text":"备注 语法为 ES6 以下排序默认按升序排序 测试案例均为自然数 前言排序作为十分经典的算法之一。是每一个软件工程师的必备技能，学好排序算法，可以提高软件的运行效率，最重要的是掌握其算法设计思想，才能举一反三应用到实际的实践中，为己所用。 排序算法简介 按照数据的大小，排序算法可以分为内部排序和外部排序（数据较大，需要借助外存） 内部排序，又可以细分为 交换排序、插入排序、选择排序 1. 冒泡排序简介：两两元素进行比较，较大者放置后头，类似水中的气泡较大者浮在水的上端性能平均时间复杂度 O(n^2) 代码：12345678910111213141516function bubble(arr) &#123; let len = arr.length, i = 0, j = 0; // 循环 n-1 趟 for (i = 0; i &lt; len; i++) &#123; // 每趟 需比较 n-i-1 次 for (j = 0; j &lt; len - 1 - i; j++) &#123; // 如果后面的元素较大，则交换两者顺序 if (arr[j + 1] &lt; arr[j]) &#123; arr[j] = [arr[j + 1], arr[j + 1] = arr[j]][0]; &#125; &#125; &#125; return arr;&#125; 2. 快速排序简介：取一个元素为基准，把序列分成两部分，小于基准的放到它的左面，大于等于的放到它的右面，然后在把左面和右面的子序列再进行上述的拆分，直到子序列不可再分割（小于2个元素），最终达到整个序列有序性能平均时间复杂度 O(n*logn) 代码1234567891011121314151617181920function quick(arr) &#123; // 不可再分割，直接退出 if (arr.length &lt;= 1) return arr; let len = arr.length, middle = len &gt;&gt; 1, pivot = (len--) &amp;&amp; arr.splice(middle, 1)[0], // 取中间为基准数，并从数组中移除 left = [], right = [], i = 0; for (i = 0; i &lt; len; i++) &#123; // 分组 小于基准的放到左边，反之 if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return [...quick(left), pivot, ...quick(right)]; // 合并&#125; 3. 简单选择排序简介：假设一个有序序列，然后由剩余的元素中选出最小的（最大的）扔到有序序列，直到无序序列元素为空，从而达到整个序列有序性能平均时间复杂度 O(n^2) 代码12345678910111213141516171819function selection(arr) &#123; let len = arr.length, i = 0, j = 0, min = i; // 循环 n-1 趟 for (i = 0; i &lt; len - 1; i++) &#123; min = i; // 假设每趟的第一个数为最小值 for (j = i + 1; j &lt; len; j++) &#123; // 如果后面的树大于最小数（min对应的数），则重新对最小值的索引赋值 if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; // 将最小数置于该趟排序的第一个位置 arr[i] = [arr[min], arr[min] = arr[i]][0]; &#125; return arr;&#125; 4. 堆排序简介：是简单选择排序的改进版，利用堆结构性能平均时间复杂度 O(n*logn) 代码12345678910111213141516171819202122232425262728293031323334// 堆排序function heapSort(arr) &#123; var n = arr.length, i, j; // 筛选 var sift = (k, m, r) =&gt; &#123; var p = k, // 父结点 c = p * 2 + 1; // 左结点（默认最大） while (c &lt;= m) &#123; // 左结点(c=m)和左右结点(c&lt;m) if (c &lt; m &amp;&amp; r[c + 1] &gt; r[c]) c++; // 选出左右结点中的最大者，指向左结点 if (r[p] &gt; r[c]) break; // 父结点大于左结点 顺序正确，退出循环 else &#123; r[p] = [r[c], r[c] = r[p]][0]; // 将大的一方置于顶部（父结点） p = c; // 向下重新指向父结点 c = p * 2 + 1; // 向下重新指向左结点 &#125; &#125; &#125;; // 构建堆 for (i = (n / 2 | 0) - 1; i &gt;= 0; i--) &#123; // 从最后一个分支结点开始向上逆序遍历 sift(i, n - 1, arr); &#125; // 排序 for (j = n - 1; j &gt;= 0; j--) &#123; arr[0] = [arr[j], arr[j] = arr[0]][0]; // 将最大的结点存于数组的最后一位 n--; // 减少数组长度，排除有序序列 sift(0, n - 1, arr, true); &#125; return arr;&#125; 5. 直接插入排序简介：假设数组的一有序序列，从后面的无序序列中，扫描，与有序序列比较，插入到合适位置性能平均时间复杂度 O(n^2) 代码12345678910111213141516171819function insertion(arr) &#123; let len = arr.length, i = 0, j = 0, temp; // [7,6,2,5,4,3,1] // 从第二个元素开始循环 for (i = 1; i &lt; len; i++) &#123; temp = arr[i]; // 存储当前元素 j = i - 1; // 待插入队列的序号 while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; // 当没有出界 且 当前元素比待插序列元素小时，进行待插序列的元素向后移动一位 arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = temp; // 将当前元素插入到待插序列的下一位 &#125; return arr;&#125; 6. 希尔排序简介：一种改进版的插入排序，每次比较的是用增量分割的序列，达到部分有序，随着增量依次递减，序列逐渐达到完全有序性能平均时间复杂度 O(n*logn) 代码123456789101112131415161718192021222324function shell(arr) &#123; let len = arr.length, i = 0, j = 0, temp, gap = 1; gap = len / 3 | 0; // 计算增量 while (gap &gt;= 1) &#123; // 增量大于2时，进行简单插入排序 for (i = gap; i &lt; len; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap = gap / 3 | 0; // 增量减少 &#125; return arr;&#125; 7. 归并排序简介：利用分治法，将序列分为许多小子序列，然后每个子序列进行排序，然后逐次合并，最后达到整体有序，这里用的是二路归并排序（归并排序中最简单的一种）性能平均时间复杂度 O(n*logn) 代码123456789101112131415161718192021222324252627282930function merge(arr) &#123; return (&#123; sortArr(leftArr, rightArr) &#123; // 排序 let res = []; // 合并 while (leftArr.length * rightArr.length !== 0) &#123; if (leftArr[0] &lt; rightArr[0]) &#123; res.push(leftArr.shift()); &#125; else &#123; res.push(rightArr.shift()); &#125; &#125; leftArr.length &gt; 0 &amp;&amp; (res = [...res, ...leftArr]); rightArr.length &gt; 0 &amp;&amp; (res = [...res, ...rightArr]); return res; &#125;, mergeArr(brr) &#123; // 合并 if (brr.length &lt;= 1) return brr; let len = brr.length, left = [], right = [], middle; middle = len &gt;&gt; 1; // 分组 left = brr.slice(0, middle); right = brr.slice(middle); return this.sortArr(this.mergeArr(left), this.mergeArr(right)); &#125; &#125;).mergeArr(arr)&#125; 8. 计数排序简介：利用分配概念，将元素一一映射到桶中，每个桶只存储单一值性能平均时间复杂度 O(n+m) 代码1234567891011121314151617181920212223242526function countingSort(arr) &#123; var max = Math.max(...arr), min = Math.min(...arr), len = arr.length, i, bucket = [], result = []; // 入桶 for (i = 0; i &lt; len; i++) &#123; var item = arr[i]; bucket[item] = bucket[item] || 0; // 建立映射表 bucket[item]++; // 相同元素对应到同一映射表中，映射表增加1 &#125; // 出桶 for (i = min; i &lt;= max; i++) &#123; var count = bucket[i]; // 取每个映射表的元素数量 while (count &gt; 0) &#123; // 如果数量大于0 ，重复输出该元素 result.push(i); count--; &#125; &#125; return result;&#125; 9. 桶排序简介：利用分配概念，每个桶存储一定范围的数值，然后桶内在进行排序，最后所有桶的元素出桶达到完全有序性能平均时间复杂度 O(n+m) 代码123456789101112131415161718192021222324252627282930313233343536function bucketSort(arr, num) &#123; var len = arr.length, max = Math.max(...arr), min = Math.min(...arr), result = [], bucket = [], space, i; // 至少2个桶 num = num &gt; 2 ? num : 2; // 计算每个桶的容量 space = ((max - min) / num | 0) + 1; // 入桶 for (i = 0; i &lt; len; i++) &#123; var item = arr[i]; var index = (item - min) / space | 0; // 计算元素入桶的位置，要放入哪个桶 bucket[index] = bucket[index] || []; bucket[index].push(item); if (bucket[index].length &gt; 1) &#123; // 桶里的元素再进行排序（这里使用的是简单插入排序） bucket[index] = insertion(bucket[index]); &#125; &#125; // 出桶 for (i = 0; i &lt; num; i++) &#123; var list = bucket[i] || []; if (list.length &gt; 0) &#123; result = result.concat(list); &#125; &#125; return result;&#125; 10. 基数排序简介：利用分配概念，根据元素的基数来分配桶 最低位优先法，简称LSD法：先从最低位开始排序，再对次低位排序，直到对最高位排序后得到一个有序序列 最高位优先法，简称MSD法：先从最高位开始排序，再逐个对各分组按次高位进行子排序，循环直到最低位 性能平均时间复杂度 O(n*m) 代码1234567891011121314151617181920212223242526272829303132function radixSort(arr) &#123; var len = arr.length, max = Math.max(...arr), bucket = [], result = [], i, j, k, hight = String(max).length; // 计算最大数的位数 for (i = 1; i &lt;= hight; i++) &#123; // 其实就是循环hight次的计数排序 result = []; bucket = []; // 入桶 for (j = 0; j &lt; len; j++) &#123; var item = arr[j] + \"\"; // 这里转换为string 类型，方便取具体位数的值，当然mod10也可以 var index = item.length - i &lt; 0 ? 0 : item.substr(item.length - i, 1); // 取第(item.len-i+1)位的数 bucket[index] = bucket[index] || []; // 这里就和计数排序一样了 bucket[index].push(+item); &#125; // 出桶 for (k = 0; k &lt; bucket.length; k++) &#123; if (bucket[k] &amp;&amp; bucket[k].length &gt; 0) &#123; result = result.concat(bucket[k]); &#125; &#125; arr = result; &#125; return result;&#125; 性能比较 sort 参考 《十大经典排序算法》","tags":[{"name":"算法","slug":"算法","permalink":"http://yangfan.site/tags/算法/"}]},{"title":"微信扫码登录原理解析","date":"2018-07-03T10:16:26.000Z","path":"2018/07/03/微信扫码登录原理解析/","text":"微信扫码登录原理解析 扫码登录是现在流行的登录方式，使用这种方式及其方便，而且安全 扫码登录流程 look.jpg 原理 获取唯一的uuid, 以及包含uid信息的二维码 12345678910111213141516171819202122232425262728293031323334353637383940414243 // 获取uuid getUUID: function() &#123; var e = t.defer(); return window.QRLogin = &#123;&#125;, $.ajax(&#123; url: i.API_jsLogin, dataType: \"script\" &#125;).done(function() &#123; 200 == window.QRLogin.code ? e.resolve(window.QRLogin.uuid) : e.reject(window.QRLogin.code) &#125;).fail(function() &#123; e.reject() &#125;), e.promise &#125;``` 2. 浏览器轮询服务器，获取扫码状态 ```js// 查看扫码状态checkLogin: function(e, a) &#123; var n = t.defer() , a = a || 0; return window.code = 0, window.checkLoginPromise = $.ajax(&#123; url: i.API_login + \"?loginicon=true&amp;uuid=\" + e + \"&amp;tip=\" + a + \"&amp;r=\" + ~new Date, dataType: \"script\", timeout: 35e3 &#125;).done(function() &#123; new RegExp(\"/\" + location.host + \"/\"); if (window.redirect_uri &amp;&amp; window.redirect_uri.indexOf(\"/\" + location.host + \"/\") &lt; 0) return void (location.href = window.redirect_uri); var e = &#123; code: window.code, redirect_uri: window.redirect_uri, userAvatar: window.userAvatar &#125;; n.resolve(e) &#125;).fail(function() &#123; n.reject() &#125;), n.promise&#125; 根据服务器返回的扫码状态，进行相应的操作 408 扫码超时 如果手机没有扫码或没有授权登录，服务器会阻塞约25s，然后返回状态码 408 -&gt; 前端继续轮询 400 二维码失效 大约5分钟的时间内不扫码，二维码失效 201 已扫码 如果手机已经扫码，服务器立即返回状态码和用户的基本信息 （window.code=201,window.code.userAvator=”…”），-&gt; 前端继续轮询 200 已授权 如果手机点击了确认登录，服务器返回200及token -&gt; 前端停止轮询, 获取到token，重定向到目标页 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 根据服务器返回的扫码状态，进行相应的操作function o(c) &#123; switch (c.code) &#123; case 200: t.newLoginPage(c.redirect_uri).then(function(t) &#123; var o = t.match(/&lt;ret&gt;(.*)&lt;\\/ret&gt;/) , r = t.match(/&lt;script&gt;(.*)&lt;\\/script&gt;/) , c = t.match(/&lt;skey&gt;(.*)&lt;\\/skey&gt;/) , s = t.match(/&lt;wxsid&gt;(.*)&lt;\\/wxsid&gt;/) , l = t.match(/&lt;wxuin&gt;(.*)&lt;\\/wxuin&gt;/) , d = t.match(/&lt;pass_ticket&gt;(.*)&lt;\\/pass_ticket&gt;/) , f = t.match(/&lt;message&gt;(.*)&lt;\\/message&gt;/) , u = t.match(/&lt;redirecturl&gt;(.*)&lt;\\/redirecturl&gt;/); return u ? void (window.location.href = u[1]) : o &amp;&amp; \"0\" != o[1] ? (alert(f &amp;&amp; f[1] || \"登陆失败\"), i.report(i.AUTH_FAIL_COUNT, 1), void location.reload()) : (e.$emit(\"newLoginPage\", &#123; Ret: o &amp;&amp; o[1], SKey: c &amp;&amp; c[1], Sid: s &amp;&amp; s[1], Uin: l &amp;&amp; l[1], Passticket: d &amp;&amp; d[1], Code: r &#125;), void (a.getCookie(\"webwx_data_ticket\") || n.report(n.ReportType.cookieError, &#123; text: \"webwx_data_ticket 票据丢失\", cookie: document.cookie &#125;))) &#125;); break; case 201: e.isScan = !0, n.report(n.ReportType.timing, &#123; timing: &#123; scan: Date.now() &#125; &#125;), t.checkLogin(e.uuid).then(o, function(t) &#123; !t &amp;&amp; window.checkLoginPromise &amp;&amp; (e.isBrokenNetwork = !0) &#125;); break; case 408: t.checkLogin(e.uuid).then(o, function(t) &#123; !t &amp;&amp; window.checkLoginPromise &amp;&amp; (e.isBrokenNetwork = !0) &#125;); break; case 400: case 500: case 0: var s = a.getCookie(\"refreshTimes\") || 0; s &lt; 5 ? (s++, a.setCookie(\"refreshTimes\", s, .5), document.location.reload()) : e.isNeedRefresh = !0; break; case 202: e.isScan = !1, e.isAssociationLogin = !1, a.setCookie(\"login_frequency\", 0, 2), window.checkLoginPromise &amp;&amp; (window.checkLoginPromise.abort(), window.checkLoginPromise = null ), r() &#125; e.code = c.code, e.userAvatar = c.userAvatar, a.log(\"get code\", c.code)&#125; 总结 轮询采用的是JSONP的形式，排除了跨域问题 轮询采用的后台根据扫码情况阻塞前台请求，优化轮询及减少前端的无效轮询","tags":[]},{"title":"Debounce and Throttle","date":"2018-06-22T08:41:29.000Z","path":"2018/06/22/Debounce-and-Throttle/","text":"防抖动与节流 DEMO 防抖动12345678910111213141516171819202122232425262728var debounce = function (fn, delay, isImmediate) &#123; var timer = null; // 默认不立即触发 isImmediate = typeof isImmediate === \"undefined\" ? false : isImmediate; return function () &#123; var ctx = this, // 保存作用域 args = arguments; // 保存参数 // 初始化清空所有定时器 if (timer) &#123; clearTimeout(timer); &#125; // 如果是立即触发 if (isImmediate) &#123; if (!timer) &#123; // timer为空时触发操作 fn.apply(ctx, args); &#125; // delay时间后置空timer timer = setTimeout(_ =&gt; &#123; timer = null; &#125;, delay); &#125; else &#123; // delay时间后触发操作 timer = setTimeout(_ =&gt; &#123; fn.apply(ctx, args); &#125;, delay); &#125; &#125;;&#125;; 防抖动立即触发 debounce-immediate.png 防抖动 debounce.png 节流123456789101112131415161718var throttle = function (fn, delay, isImmediate) &#123; var timer = null; // 默认立即触发 isImmediate = typeof isImmediate === \"undefined\" ? true : isImmediate; return function () &#123; var ctx = this, // 保存作用域 args = arguments; // 保存参数 if (!timer) &#123; // timer为空时 if (isImmediate) fn.apply(ctx, args); // 立即触发 timer = setTimeout(function () &#123; clearTimeout(timer); timer = null; if (!isImmediate) fn.apply(ctx, args); // delay时间后触发操作 &#125;, delay); &#125; &#125;;&#125;; 节流立即触发 throttle-immediate.png 节流 throttle.png 总结 防抖动：将多个操作合并为一个操作（例如，键盘输入关键字搜索内容），在规定延时时间后触发，如果在定时器时间范围内触发，则会清楚定时器，重新计时 节流：在给定的延时时间后触发一次操作，在此时间范围内的操作均不触发（例如，图片懒加载、向下无限滚动获取新数据）","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"网站优化","slug":"网站优化","permalink":"http://yangfan.site/tags/网站优化/"}]},{"title":"浏览器杂谈","date":"2018-06-05T02:56:31.000Z","path":"2018/06/05/浏览器杂谈/","text":"浏览器缓存（协议层的缓存） 主要分为强缓存和协商缓存，详情 https://segmentfault.com/a/1190000011212929 强缓存 浏览器会先获取该资源缓存的header信息，根据其中的Expires和Cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源 协商缓存 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 reflow(重排)和repaint(重绘) reflow &amp; repainthttps://www.jianshu.com/p/40c6fc1d4800http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html 浏览器解析网页的过程 HTML代码转化成DOM CSS代码转化成CSSOM（CSS Object Model） 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 重排与重绘 重排：渲染树的结点发生了结构性变化，例如宽度、高度或者位置上的变化时，那么会触发reflow(重排)的逻辑。第一次进入一个页面时便会至少触发一次重排。 重绘：渲染树结点发生了非结构性变化，例如背景色等的变化时，那么会触发repaint(重绘)。 AST（抽象语法树）定义抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上 应用抽象语法树的作用非常的多，比如编译器、IDE、压缩优化代码等。在JavaScript中，虽然我们并不会常常与AST直接打交道，但却也会经常的涉及到它。例如使用UglifyJS来压缩代码，实际这背后就是在对JavaScript的抽象语法树进行操作，例如 Babel编译ES6的代码","tags":[]},{"title":"浏览器兼容性问题Q&A","date":"2018-05-14T03:07:01.000Z","path":"2018/05/14/浏览器兼容性问题Q-A/","text":"浏览器兼容性问题Q&amp;ADate 对象时间格式差异性Q: 日期参数为 yyyy/MM/dd hh:mm:ss 格式时，IE浏览器不支持，chrome和firefox支持1new Date(\"2018-05-05 12:25:23\") // Invalid Date 日期参数为 yyyy/MM/ddThh:mm:ss 格式时，IE支持,chrome和firefox也支持 1new Date(\"2018-05-05T12:25:23\") // [date] Sat May 05 2018 12:25:23 GMT+0800 (中国标准时间) A:原因：各个浏览器对采用的时间格式标准解析不一致 解决方法：最好采用ISO的标准时间格式YYYY-MM-DDTHH:mm:ss.sssZ或者使用时间戳代替 123456new Date(\"2018-05-05T12:25:23.235Z\");// ornew Date(1525523123235) window.open 在异步代码中执行被浏览器拦截Q:下面方式打开新页面会被浏览器拦截1234567891011121314// 异步代码setTimeout(function () &#123; window.open(\"http://www.sogou.com\")&#125;,1001)// AJAX异步请求$.ajax(&#123; url:\"xxx\", success:function () &#123; window.open(\"yyy\") &#125;&#125;); A:原因：出于安全考虑浏览器会拦截掉非用户操作的行为 解决方法：12345678// window.open()先执行，打开一个空的窗口（例如 加载页）var newWin = window.open('http://xxx.com/loading.html')// 然后等异步代码执行完再重定向 newWin.location.href = 'http://www.baidu.com' a 标签href属性为javascript:void(0) 时，各浏览器处理方式不同Q:1&lt;a href=\"javascript:void(0)\" target=\"_blank\"&gt;我是空链接，在这里当做一个按钮&lt;/a&gt; firefox和IE浏览器会弹出一个新窗口 A:原因：浏览器默认处理事件的顺序有差异。Chrome顺序：onclick -&gt; href -&gt; targetIE和Firefox顺序：onclick -&gt; target -&gt; href 解决方法： 添加onclick事件，直接return false阻止之后浏览器默认事件的执行 1&lt;a target=\"_blank\" onclick=\"return false\" href=\"javascript:void(0);\"&gt;点我啊&lt;/a&gt; 去掉href属性 1&lt;a target=\"_blank\"&gt;点我啊&lt;/a&gt; 1&lt;a&gt;点我啊&lt;/a&gt; 各浏览器对 table 不规范写法解析不一致最好以W3C的标准来写HTML，不然浏览器对HTML解析有差异 1234567891011121314151617181920&lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 鼠标事件 mouseout 和 mouseleave 区别 mouseleave 只有鼠标移开被监听的元素时，才触发 （mouseenter同理） mouseout 不论鼠标移开被监听元素，还是子元素，均会触发（mouseover同理） window.URL.createObjectURL(new Blob) 在Microsoft IE和Chrome 的区别 https://blog.csdn.net/u013131203/article/details/80894440Chrome 带域名 123URL.createObjectURL(new Blob())// \"blob:https://note.youdao.com/e4132750-7b95-4595-b331-158267d8d9e3\" ie不带域名 123URL.createObjectURL(new Blob())// \"blob:e4132750-7b95-4595-b331-158267d8d9e3\" IE浏览器缓存 get方式的XHR请求 https://www.cnblogs.com/bk233/p/7280595.html每次发请求时携带一个随机参数 例如 GET http://123.com?t=15123153156161 浅谈 AJAX 跨域请求时的 OPTIONS 方法 https://juejin.im/entry/58eaf351a22b9d0058a8e35cFor cross-domain requests, setting the content type to anything other than application/x-www-form-urlencoded, multipart/form-data, or text/plain will trigger the browser to send a preflight OPTIONS request to the server.非简单请求必须先发送预检请求，如果发送的请求内容类型如果不是 application/x-www-form-urlencoded，multipart/form-data 或 text/plain 这三者的话，便会触发 OPTIONS 请求","tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yangfan.site/tags/浏览器/"},{"name":"兼容性","slug":"兼容性","permalink":"http://yangfan.site/tags/兼容性/"}]},{"title":"Git上传文件到Github","date":"2018-05-08T04:08:03.000Z","path":"2018/05/08/Git上传文件到Github/","text":"Git上传文件到Github Git commnd First Commit123456789101112131415161718# initgit init# add remote origingit remote add origin https://github.com/username/xxxx.git# pullgit pull https://github.com/username/xxxx.git master# addgit add .# commitgit commit -m \"注释\"# pushgit push -u origin master Commit1234#pushgit push origin master","tags":[{"name":"博客","slug":"博客","permalink":"http://yangfan.site/tags/博客/"},{"name":"Git","slug":"Git","permalink":"http://yangfan.site/tags/Git/"}]},{"title":"Vue工程化开发（一）","date":"2018-01-12T02:58:42.000Z","path":"2018/01/12/Vue工程化开发（一）/","text":"Vue工程化开发（一） 利用Vue-cli脚手架在现有的MVC项目中进行前端开发 开发环境 Node npm Vue-cli 搭建项目1. 首先在项目中搭建一个前台文件夹，用 vue init webpack projectname （例如: vue init webpack frontend）frontend 为Vue-cli自动生成的项目文件content 目录下存放打包后的资源文件views目录下存放自动生成的cshtml文件 2. 进入此文件夹（这里是 frontend） 配置 package.json ，安装所需插件 3. 修改打包配置 进入 config/index.js 修改如下 4. 在当前目录下新建一个模板页 index.cshtml 如下 5. 修改打包html文件的配置 进入 build/webpack.prod.conf.js 6. npm run dev 测试7. npm run build 打包项目目录","tags":[]},{"title":"[转]如何监听DOM树改变","date":"2017-11-08T02:06:44.000Z","path":"2017/11/08/转-如何监听DOM树改变/","text":"如何监听DOM树改变[转]读前必看MutationObserver MDNhttps://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver Mutation Observer API http://javascript.ruanyifeng.com/dom/mutationobserver.html#toc10 1 概述Mutation observer 是用于代替 Mutation events 作为观察DOM树结构发生变化时，做出相应处理的API。为什么要使用mutation observer 去代替 mutation events 呢，我们先了解一下mutation events Mutation Events Mutation events 是在 DOM3中定义，用于监听DOM树结构变化的事件 它简单的用法如下：1234document.getElementById('list').addEventListener(\"DOMSubtreeModified\", function()&#123; console.log('列表中子元素被修改');&#125;, false); Mutation 事件列表DOMAttrModifiedDOMAttributeNameChangedDOMCharacterDataModifiedDOMElementNameChangedDOMNodeInsertedDOMNodeRemovedDOMNodeInsertedIntoDocumentDOMSubtreeModified 其中DOMNodeRemoved，DOMNodeInserted 和 DOMSubtreeModified 分别用于 监听元素子项的删除，新增，修改(包括删除和新增），DOMAttrModified 是监听元素属性的修改，并且能够提供具体的修改动作。 Mutation Events遇到的问题浏览器兼容性问题IE9不支持Mutation EventsWebkit内核不支持DOMAttrModified特性，DOMElementNameChanged和DOMAttributeNameChanged 在Firefox上不被支持。性能问题 Mutation Events是同步执行的，它的每次调用，都需要从事件队列中取出事件，执行，然后事件队列中移除，期间需要移动队列元素。如果事件触发的较为频繁的话，每一次都需要执行上面的这些步骤，那么浏览器会被拖慢。 Mutation Events本身是事件，所以捕获是采用的是事件冒泡的形式，如果冒泡捕获期间又触发了其他的MutationEvents的话，很有可能就会导致阻塞Javascript线程，甚至导致浏览器崩溃。 Mutation Observer Mutation Observer 是在DOM4中定义的，用于替代 mutation events 的新API，它的不同于events的是，所有监听操作以及相应处理都是在其他脚本执行完成之后异步执行的，并且是所以变动触发之后，将变得记录在数组中，统一进行回调的，也就是说，当你使用observer监听多个DOM变化时，并且这若干个DOM发生了变化，那么observer会将变化记录到变化数组中，等待一起都结束了，然后一次性的从变化数组中执行其对应的回调函数。 Mutation Observer 的浏览器兼容范围 兼容性2 方法构造函数用来实例化一个Mutation观察者对象，其中的参数是一个回调函数，它是会在指定的DOM节点发送变化后，执行的函数，并且会被传入两个参数，一个是变化记录数组(MutationRecord)，另一个是观察者对象本身 12new MutationObserver(function(records, itself)&#123;&#125;); observe 在观察者对象上，注册需要观察的DOM节点，以及相应的参数 12void observe(Node target, optional MutationObserverInit options) 其中的可选参数 MutationObserverInit的属性如下： childLIst 观察目标节点的子节点的新增和删除。attributes 观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化)。characterData 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化subtree 观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化)attributeOldValue 在attributes属性已经设为true的前提下, 将发生变化的属性节点之前的属性值记录下来(记录到下面MutationRecord对象的oldValue属性中)characterDataOldValue 在characterData属性已经设为true的前提下,将发生变化characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中)attributeFilter 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些删选参数的话，如果想要使用哪个参数的话，就将其值设定为true disconnect 暂定在观察者对象上设置的节点的变化监听，直到重新调用observe方法 takeRecords 在观察者对象上调用takeRecords 会返回 其观察节点上的变化记录(MutationRecord)数组其中MutationRecord数组也会作为，观察者初始化时的回调函数的第一个参数其包含的属性如下： type 如果是属性发生变化,则返回attributes.如果是一个CharacterData节点发生变化,则返回characterData,如果是目标节点的某个子节点发生了变化,则返回childList.target 返回此次变化影响到的节点,具体返回那种节点类型是根据type值的不同而不同的,如果type为attributes,则返回发生变化的属性节点所在的元素节点,如果type值为characterData,则返回发生变化的这个characterData节点.如果type为childList,则返回发生变化的子节点的父节点.addedNodes 返回被添加的节点removedNodes 返回被删除的节点previousSibling 返回被添加或被删除的节点的前一个兄弟节点nextSibling 返回被添加或被删除的节点的后一个兄弟节点attributeName 返回变更属性的本地名称oldValue 根据type值的不同,返回的值也会不同.如果type为attributes,则返回该属性变化之前的属性值.如果type为characterData,则返回该节点变化之前的文本数据.如果type为childList,则返回null 3 使用实例1234567891011121314151617// Firefox和Chrome早期版本中带有前缀var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver// 选择目标节点var target = document.querySelector('#some-id'); // 创建观察者对象var observer = new MutationObserver(function(mutations) &#123; mutations.forEach(function(mutation) &#123; console.log(mutation.type); &#125;); &#125;); // 配置观察选项:var config = &#123; attributes: true, childList: true, characterData: true &#125; // 传入目标节点和观察选项observer.observe(target, config); // 随后,你还可以停止观察observer.disconnect(); 原文：http://www.jianshu.com/p/b5c9e4c7b1e1","tags":[]},{"title":"axios 入门","date":"2017-10-12T01:00:50.000Z","path":"2017/10/12/axios-入门/","text":"axios 入门请忽略大图，不只是Vue，其他js均可用 001 Editor: Yangfan 2017-08-17Intro: 本文档参考axios的官方文档和网上的axios使用教程所写，后续还会不断完善，鄙人水平有限，还望批评指正 强烈建议查看完整文档，链接如下 英文原文档： https://github.com/mzabriskie/axios 中文文档：https://www.awesomes.cn/repo/mzabriskie/axioshttps://segmentfault.com/a/1190000008470355 什么是axios引用axios的介绍： Promise based HTTP client for the browser and node.js axios是一个基于ES6的Promise的网络请求库，是一个ajax库。 可以实现： 在浏览器里建立XHR 通过nodejs进行http请求 甚至可以实现： 转换或者拦截请求数据或响应数据 支持Promise的API 可以取消请求 自动转换JSON 可以防御XSRF攻击！ 浏览器支持也没什么问题，IE这种本时代异端都能支持到8+，这问题是不大了。（VUE支持到9+！） Chrome](https://raw.github.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png) | ![Firefox](https://raw.github.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png) | ![Safari](https://raw.github.com/alrra/browser-logos/master/src/safari/safari_48x48.png) | ![Opera](https://raw.github.com/alrra/browser-logos/master/src/opera/opera_48x48.png) | ![Edge](https://raw.github.com/alrra/browser-logos/master/src/edge/edge_48x48.png) | ![IE Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ [ Browser Matrix](https://saucelabs.com/open_sauce/build_matrix/axios.svg) 怎么用方法一 npm安装 npm下载 1npm install axios webpack之类的打包工具导入 12345678910111213141516171819202122import axios from 'axios'// orvar axios=require('axios');//===============Vue===================// Vue全局引用及使用import axios from 'axios'Vue.prototype.$http = axiosthis.$http.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 方法二 script标签引入12&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 用法及DEMO简单的demo一个简单的HTTP GET请求 12345678910111213141516171819202122232425// 法一 请求参数写到url中axios.get('http://getRes.php?id=123456&amp;name=Yangfan').then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;);// 法二 请求参数写到axios配置参数中axios.get('http://getRes.php'，&#123; params:&#123; id:123456, name:\"Yangfan\" &#125;&#125;).then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;); 一个简单的HTTP POST 请求 1234567891011axios.post('http://getRes.php',&#123; id:123456, name:\"Yangfan\"&#125;).then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;); 自定义请求配置 123456789101112131415161718192021// 配置var config=&#123; method: 'GET', // 请求方法 url: 'http://getRes.php', // 请求url headers: &#123; token: 'ftv1443qby6bdfa41t90sfvq89hg3h54u989m9imog79g4' // 请求头 &#125;, data: &#123; // 需要传递的数据 id: 123456, name: 'Yangfan' &#125;&#125;;axios(config).then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;); 完整配置 参数 类型 注解 url String url是服务器链接，用来请求 method String method是发起请求时的请求方法 baseURL String baseURL如果url不是绝对地址，那么将会加在其前面。 transformRequest Function transformRequest允许请求的数据在传到服务器之前进行转化。 transformResponse Function transformResponse允许返回的数据传入then/catch之前进行处理 headers Object headers是自定义的要被发送的头信息 params Object params是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象 paramsSerializer Function paramsSerializer是一个可选的函数，是用来序列化参数 data Object data是请求提需要设置的数据 只适用于应用的’PUT’,’POST’,’PATCH’，请求方法 当没有设置transformRequest时，必须是以下其中之一的类型（不可重复？）： -string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams -仅浏览器：FormData,File,Blob -仅Node：Stream timeout Number timeout定义请求的时间，单位是毫秒。 withCredentials Boolean withCredentials表明是否跨网站访问协议， adapter Function adapter适配器，允许自定义处理请求，这会使测试更简单。 auth Object auth表明HTTP基础的认证应该被使用，并且提供证书。 这个会设置一个authorization 头（header），并且覆盖你在header设置的Authorization头信息。 responseType String responsetype表明服务器返回的数据类型，这些类型的设置应该是 ‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’ xsrfCookieName String xsrfCookieName是cookie名，用作xsrf token值 xsrfHeaderName String xsrfHeaderName 是http头（header）的名字，并且该头携带xsrf的值 onUploadProgress Function onUploadProgress允许处理上传过程的事件 onDownloadProgress Function onDownloadProgress允许处理下载过程的事件 maxContentLength Number maxContentLength 定义http返回内容的最大容量 validateStatus Function validateStatus 定义promise的resolve和reject。 http返回状态码，如果validateStatus返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。 maxRedirects Number maxRedirects定义了node.js中要重定向的最大数量。 如果设置为0，则不会重定向。 httpAgent Object httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 httpsAgent Object httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 proxy Object proxy定义服务器的主机名字和端口号。 auth表明HTTP基本认证应该跟proxy相连接，并且提供证书。 这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。 cancelToken Function cancelTaken 定义一个取消，能够用来取消请求 返回结果1234567891011121314151617&#123; // 服务器返回的数据 data: &#123;&#125;, // 服务器返回的状态码 status: 200, // 服务器返回的状态信息 statusText: 'OK', // 服务器返回的响应头信息 headers: &#123;&#125;, // `config`是提供给`axios`的请求的配置 config: &#123;&#125;&#125;","tags":[]},{"title":"[转]如何监听JS变量的变化","date":"2017-09-20T06:04:08.000Z","path":"2017/09/20/转-如何监听JS变量的变化/","text":"如何监听JS变量的变化[转]读前必看Object.defineProperty() https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty 如何监听 js 中变量的变化?我现在有这样一个需求，需要监控js的某个变量的改变，如果该变量发生变化，则触发一些事件，不能使用timeinterval之类的定时去监控的方法，不知道有比较好的解决方案么？ 这个问题问的很好。 流行的MVVM的JS库/框架都有共同的特点就是数据绑定，在数据变更后响应式的自动进行相关计算并变更DOM展现。所以这个问题也可以理解为如何实现MVVM库/框架的数据绑定。 常见的数据绑定的实现有脏值检测，基于ES5的getter和setter，以及ES已被废弃的Object.observe，和ES6中添加的Proxy。 脏值检测angular使用的就是脏值检测，原理是比较新值和旧值，当值真的发生改变时再去更改DOM，所以angular中有一个$digest。那么为什么在像ng-click这样的内置指令在触发后会自动变更呢？原理也很简单，在ng-click这样的内置指令中最后追加了$digest。 简易的实现一个脏值检测： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;two-way binding&lt;/title&gt; &lt;/head&gt; &lt;body onload=\"init()\"&gt; &lt;button ng-click=\"inc\"&gt; Increase &lt;/button&gt; &lt;button ng-click=\"reset\"&gt; Reset &lt;/button&gt; &lt;span style=\"color:red\" ng-bind=\"counter\"&gt;&lt;/span&gt; &lt;span style=\"color:blue\" ng-bind=\"counter\"&gt;&lt;/span&gt; &lt;span style=\"color:green\" ng-bind=\"counter\"&gt;&lt;/span&gt; &lt;script type=\"text/javascript\"&gt; /* 数据模型区开始 */ var counter = 0; function inc() &#123; counter++; &#125; function reset() &#123; counter = 0; &#125; /* 数据模型区结束 */ /* 绑定关系区开始 */ function init() &#123; bind(); &#125; function bind() &#123; var list = document.querySelectorAll(\"[ng-click]\"); for (var i=0; i&lt;list.length; i++) &#123; list[i].onclick = (function(index) &#123; return function() &#123; window[list[index].getAttribute(\"ng-click\")](); apply(); &#125;; &#125;)(i); &#125; &#125; function apply() &#123; var list = document.querySelectorAll(\"[ng-bind='counter']\"); for (var i=0; i&lt;list.length; i++) &#123; if (list[i].innerHTML != counter) &#123; list[i].innerHTML = counter; &#125; &#125; &#125; /* 绑定关系区结束 */ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样做的坏处是自己变更数据后，是无法自动改变DOM的，必须要想办法触发apply()，所以只能借助ng-click的包装，在ng-click中包含真实的click事件监听并追加脏值检测以判断是否要更新DOM。 另外一个坏处是如果不注意，每次脏值检测会检测大量的数据，而很多数据是没有检测的必要的，容易影响性能。 关于如何实现一个和angular一样的脏值检测，知道原理后还有很多工作要去做，以及如何优化等等。如果有兴趣可以看看民工叔曾经推荐的《Build Your Own Angular.js》，第一章Scope便讲了如何实现angular的作用域和脏值检测。对了，上面的例子也是从民工叔的博客稍加修改来的，建议最后去看下原文，链接在参考资料中。 ES5的getter与setter在ES5中新增了一个Object.defineProperty，直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 12Object.defineProperty(obj, prop, descriptor) 其接受的第三个参数可以取get和set并各自对应一个getter和setter方法： 123456789101112131415var a = &#123; zhihu:0 &#125;;Object.defineProperty(a, 'zhihu', &#123; get: function() &#123; console.log('get：' + zhihu); return zhihu; &#125;, set: function(value) &#123; zhihu = value; console.log('set:' + zhihu); &#125;&#125;);a.zhihu = 2; // set:2console.log(a.zhihu); // get：2 // 2 基于ES5的getter和setter可以说几乎完美符合了要求。为什么要说几乎呢？ 首先IE8及更低版本IE是无法使用的，而且这个特性是没有polyfill的，无法在不支持的平台实现，这也是基于ES5getter和setter的Vue.js不支持IE8及更低版本IE的原因。也许有人会提到avalon，avalon在低版本IE借助vbscript一些黑魔法实现了类似的功能。 除此之外，还有一个问题就是修改数组的length，直接用索引设置元素如items[0] = {}，以及数组的push等变异方法是无法触发setter的。如果想要解决这个问题可以参考Vue的做法，在Vue的observer/array.js中，Vue直接修改了数组的原型方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)/** * Intercept mutating methods and emit events */;[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) &#123; // cache original method var original = arrayProto[method] def(arrayMethods, method, function mutator () &#123; // avoid leaking arguments: // http://jsperf.com/closure-with-arguments var i = arguments.length var args = new Array(i) while (i--) &#123; args[i] = arguments[i] &#125; var result = original.apply(this, args) var ob = this.__ob__ var inserted switch (method) &#123; case 'push': inserted = args break case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 这样重写了原型方法，在执行数组变异方法后依然能够触发视图的更新。 但是这样还是不能解决修改数组的length和直接用索引设置元素如items[0] = {}的问题，想要解决依然可以参考Vue的做法：前一个问题可以直接用新的数组代替旧的数组；后一个问题可以为数组拓展一个$set方法，在执行修改后顺便触发视图的更新。 已被废弃的Object.observeObject.observe曾在ES7的草案中，并在提议中进展到stage2，最终依然被废弃。这里只举一个MDN上的例子： 1234567891011121314151617181920// 一个数据模型var user = &#123; id: 0, name: 'Brendan Eich', title: 'Mr.'&#125;;// 创建用户的greetingfunction updateGreeting() &#123; user.greeting = 'Hello, ' + user.title + ' ' + user.name + '!';&#125;updateGreeting();Object.observe(user, function(changes) &#123; changes.forEach(function(change) &#123; // 当name或title属性改变时, 更新greeting if (change.name === 'name' || change.name === 'title') &#123; updateGreeting(); &#125; &#125;);&#125;); 由于是已经废弃了的特性，Chrome虽然曾经支持但也已经废弃了支持，这里不再讲更多，有兴趣可以搜一搜以前的文章，这曾经是一个被看好的特性（Object.observe()带来的数据绑定变革）。当然关于它也有一些替代品Polymer/observe-js。 ES6带来的Proxy人如其名，类似HTTP中的代理： 1234var p = new Proxy(target, handler);target为目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。handler为处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。 举个例子： 1234567891011let a = new Proxy(&#123;&#125;, &#123; set: function(obj, prop, value) &#123; obj[prop] = value; if (prop === 'zhihu') &#123; console.log(\"set \" + prop + \": \" + obj[prop]); &#125; return true; &#125;&#125;);a.zhihu = 100; 当然，Proxy的能力远不止此，还可以实现代理转发等等。 但是要注意的是目前浏览器中只有Firefox18支持这个特性，而babel官方也表明不支持这个特性： Unsupported featureDue to the limitations of ES5, Proxies cannot be transpiled or polyfilled. 目前已经有babel插件可以实现，但是据说实现的比较复杂。如果是Node的话升级到目前的最新版本应该就可以使用了，上面的例子测试环境为Node v6.4.0。 原文：https://blog.daraw.cn/2016/08/17/how-to-monitor-changes-of-js-variable/","tags":[]},{"title":"shell常用命令","date":"2017-07-16T11:59:04.000Z","path":"2017/07/16/shell常用命令/","text":"shell常用命令1 ls命令：列出文件 ls -la 列出当前目录下的所有文件和文件夹 ls a* 列出当前目录下所有以a字母开头的文件 ls -l *.txt 列出当前目录下所有后缀名为txt的文件 2 cp命令：复制cp a.txt b.txt 把文件a的内容复制到b文件 cp a.txt ./test 把文件a复制到text目录下 cp -a test test2 递归的把目录test下所有文件（包括隐藏的文件）复制到新的目录 test2 3 cat命令：查看 组合文件cat a.txt 查看文件的内容 cat a.txt &gt;&gt; b.txt 把a文件的内容组合到b文件内容的末尾 cat -n a.txt 查看文件并给文件标上行号 4 touch命令：建立文件touch a.txt 建立一个名为a的txt类型文件 5 rm命令：删除文件rm -rf a.txt 强制删除文件a.txt rm -i a.txt 删除文件前会有提示是否确定删除该文件 6 mkdir命令：创建目录mkdir test 创建一个名为test的目录 7 rmdir命令：删除目录rmdir test 删除一个目录 8 echo、cat命令：添加内容echo “hello world!” &gt;&gt; a.txt 添加内容到文件a里面 cat &lt;&lt;EOF&gt;&gt; a.txt 可以添加多行语句到文件本身内容的末尾 cat &lt;&lt;EOF&gt; a.txt 添加内容到文件并覆盖到原始的内容 9 mv命令：移动 重命名文件mv a.txt b.txt 文件a重新命名为b mv a.txt ./test 把文件移动到一个目录下 10 cd命令：更换目录cd ~ 切换到用户目录 cd .. 返回到上一层目录 cd ../.. 返回到上二层目录 11 grep命令：搜索文件ls -la | grep a.txt 搜索a.txt文件 12 find命令：查找文件和目录find filename 查找当前目录下是否有该文件/目录 13 rz sz命令：上传和下载文件14 head命令：显示文件的前10行内容15 tail命令：显示文件最后10行内容","tags":[]},{"title":"高德地图 Javascript API 入门（八）","date":"2017-03-07T13:57:02.000Z","path":"2017/03/07/高德地图 Javascript API 入门（八）/","text":"高德地图 Javascript API 入门（八）点聚合插件用于地图上加载大量点标记，提高地图浏览性能。点聚合支持用户自定义点标记 加载地图123456// 加载地图var map=new AMap.Map(\"container\",&#123; resizeEnable:true, center:[116.397428, 39.90923], zoom:11&#125;); 生成点标记1234567891011// 生成点标记var markers=[];var marker=null;for (var i=0;i&lt;100;i++) &#123; marker=new AMap.Marker(&#123; position:[116.39+0.001*Math.random()*i, 39.90-0.001*Math.random()*i], icon: \"http://amappc.cn-hangzhou.oss-pub.aliyun-inc.com/lbs/static/img/marker.png\" &#125;); marker.setMap(map); markers.push(marker);&#125; 载入点聚合插件 默认样式 123map.plugin([\"AMap.MarkerClusterer\"],function () &#123; var cluster=new AMap.MarkerClusterer(map,markers);&#125;); 预览 image 自定义样式 1234567891011121314151617181920212223// 聚合样式var sts=[&#123; url:\"http://a.amap.com/lbs/static/img/1102-1.png\", size:new AMap.Size(32,32), offset:new AMap.Pixel(-16,-30), imageOffset:new AMap.Pixel(0,0)&#125;,&#123; url:\"http://a.amap.com/lbs/static/img/2.png\", size:new AMap.Size(32,32), offset:new AMap.Pixel(-16,-30)&#125;,&#123; url:\"http://lbs.amap.com/wp-content/uploads/2014/06/3.png\", size:new AMap.Size(32,32), offset:new AMap.Pixel(-16,-30), textColor:\"#f00\", textSize:30&#125;];// 载入插件map.plugin([\"AMap.MarkerClusterer\"],function () &#123; var cluster=new AMap.MarkerClusterer(map,markers,&#123; styles:sts &#125;);&#125;); 预览 image MarkerClustererOptionsMarkerClustererOptions类型说明gridSizeNumber聚合计算时网格的像素大小，默认60minClusterSizeNumber聚合的最小数量。默认值为2，即小于2个点则不能成为一个聚合maxZoomNumber最大的聚合级别，大于该级别就不进行相应的聚合。默认值为18，即小于18级的级别均进行聚合，18及以上级别不进行聚合averageCenterBoolean聚合点的图标位置是否是所有聚合内点的中心点。默认为否，即聚合点的图标位置位于聚合内的第一个点处stylesArray&lt;Object&gt;自定义聚合后的点标记图标的样式，根据数组元素顺序设置1-10,11-100,101-1000…聚合样式当用户设置聚合样式少于实际叠加的点数，未设置部分按照系统默认样式显示单个图标样式包括以下几个属性：1. {string}url：图标显示图片的url地址（必选）2. {AMap.Size}size：图标显示图片的大小（必选）3. {AMap.Pixel} offset：图标定位在地图上的位置相对于图标左上角的偏移值。默认为(0,0),不偏移（可选）4. {AMap.Pixel} imageOffset：图片相对于可视区域的偏移值，此功能的作用等同CSS中的background-position属性。默认为(0,0)，不偏移（可选）5. {String} textColor：文字的颜色，默认为”#000000”（可选）6. {Number} textSize：文字的大小，默认为10（可选）zoomOnClickBoolean点击聚合点时，是否散开，默认值为：true 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（七）","date":"2017-03-04T13:03:02.000Z","path":"2017/03/04/高德地图 Javascript API 入门（七）/","text":"高德地图 Javascript API 入门（七）热力图插件简单例子1234567891011121314151617181920212223242526// 显示地图var map=new AMap.Map(\"container\",&#123; resizeEnable:true, center:[116.397428, 39.90923], zoom:11&#125;);// 坐标点var points =[ &#123;\"lng\":116.191031,\"lat\":39.988585,\"count\":100&#125;, &#123;\"lng\":116.389275,\"lat\":39.925818,\"count\":60&#125;, &#123;\"lng\":116.287444,\"lat\":39.810742,\"count\":200&#125;, &#123;\"lng\":116.481707,\"lat\":39.940089,\"count\":30&#125;, &#123;\"lng\":116.410588,\"lat\":39.880172,\"count\":200&#125;, &#123;\"lng\":116.394816,\"lat\":39.91181,\"count\":10&#125;, &#123;\"lng\":116.416002,\"lat\":39.952917,\"count\":150&#125;];// 加载热力图插件map.plugin([\"AMap.Heatmap\"],function () &#123; var heatmap=new AMap.Heatmap(map,&#123; radius:50 &#125;); heatmap.setDataSet(&#123; data:points, max:100 &#125;);)&#125;; 预览 image 参数AMap.Heatmap 构造函数说明AMap.Heatmap(map:Map,opts:HeatmapOptions)构造一个热力图插件对象，map为要叠加热力图的地图对象，opts属性参考HeatmapOptions列表中的说明。 options HeatmapOptions类型说明radiusNumber热力图中单个点的半径，默认：30，单位：pixelgradientObject热力图的渐变区间，热力图按照设置的颜色及间隔显示热力图，例：{0.4:’rgb(0, 255, 255)’,0.65:’rgb(0, 110, 255)’,0.85:’rgb(100, 0, 255)’,1.0:’rgb(100, 0, 255)’} 其中 key 表示间隔位置，取值范围： [0,1]，value为颜色值。默认：heatmap.js标准配色方案opacityArray热力图透明度数组，取值范围[0,1]，0表示完全透明，1表示不透明，默认：[0,1]zoomsArray支持的缩放级别范围，取值范围[3-18]，默认：[3,18] 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（六）","date":"2017-02-28T10:03:02.000Z","path":"2017/02/28/高德地图 Javascript API 入门（六）/","text":"高德地图 Javascript API 入门（六）出行规划公交路径公交换乘服务，提供起、终点公交路线规划服务，整合步行方式 初始化 1234567891011// 加载公交线路插件AMap.service(\"AMap.Transfer\",function () &#123; // 实例化Transfer var transfer=new AMap.Transfer(&#123; city:\"北京\", // 必须值，搭乘公交所在城市 map:map, // 可选值，搜索结果的标注、线路等均会自动添加到此地图上 panel:\"panel\", // 可选值，显示搜索列表的容器, extensions:\"all\", // 可选值，详细信息 poliy:AMap.TransferPolicy.LEAST_TIME // 驾驶策略：最省时模式 &#125;);&#125;); 按关键字搜索 1234// 关键字搜索transfer.search([&#123;keyword:\"北京西站\"&#125;,&#123;keyword:\"天安门\"&#125;],function (status,result) &#123; window.top.data=result;&#125;); 按坐标搜索 1234// 按坐标搜索transfer.search([116.379028, 39.865042], [116.427281, 39.903719],function (status,result) &#123; window.top.data=result;&#125;); 预览 驾车路径驾车路线规划服务，提供起、终点坐标的驾车导航路线查询功能 初始化 12345678910111213141516// 加载驾车路径插件AMap.service(\"AMap.Driving\",function () &#123; // 实例化Driving var driving=new AMap.Driving(&#123; map:map, // 用来承载 显示路径 panel:\"panel\", // 显示搜索列表的容器 extensions:\"all\", // 详细信息 policy:AMap.DrivingPolicy.REAL_TRAFFIC, // 驾驶策略：合理交通 showTraffic:true, // 是否显示路况 province:\"晋\", // 判断限行 number:\"A88888\", // 判断限行 hideMarkers:false, // 隐藏起点、终点的点标注 isOutline:true, // 是否显示线路的边框 outlineColor:\"#f00\" // 边框颜色 &#125;);&#125;); 按关键字搜索 1234// 按关键字搜索 driving.search([&#123;keyword:\"北京西站\",city:\"北京\"&#125;,&#123;keyword:\"天安门\",city:\"北京\"&#125;],function (status,result) &#123; window.top.data=result; &#125;); 按坐标搜索 1234// 按坐标搜索driving.search([116.379028, 39.865042], [116.427281, 39.903719],function (status,result) &#123; window.top.data=result; &#125;); 预览 image 限行结果0 代表限行已规避或未限行，即该路线没有限行路段1 代表限行无法规避，即该线路有限行路段 image 步行路径步行导航服务，提供起、终点步行路线规划服务 初始化 1234567// 加载步行路径插件AMap.service(\"AMap.Walking\",function () &#123; var walking=new AMap.Walking(&#123; map:map, panel:\"panel\" &#125;);&#125;); 按关键字搜索 123walking.search([&#123;keyword:\"方恒国际中心A座\"&#125;,&#123;keyword:\"望京站\"&#125;],function (status,result) &#123; window.top.data=result;&#125;); 按坐标搜索 123walking.search([116.379028, 39.865042],[116.427281, 39.903719],function (status,result) &#123; window.top.data=result;&#125;); 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（五）","date":"2017-02-26T14:03:02.000Z","path":"2017/02/26/高德地图 Javascript API 入门（五）/","text":"高德地图 Javascript API 入门（五）搜索服务搜索服务名称说明是否插件AMap.Autocomplete输入提示，根据输入关键字提示匹配信息是AMap.PlaceSearch地点搜索服务插件，提供某一特定地区的位置查询服务是AMap.PlaceSearchLayer麻点图插件，提供海量搜索结果的辅助显示功能是AMap.DistrictSearch行政区查询服务，提供行政区相关信息是AMap.LineSearch公交路线服务，提供公交路线相关信息查询服务是AMap.StationSearch公交站点查询服务，提供途经公交线路、站点经纬度等信息是 地点搜索插件 AMap.PlaceSearch 创建地点查询类的实例 123456789101112// 创建地点查询类的实例AMap.service(\"AMap.PlaceSearch\",function () &#123; var s1=new AMap.PlaceSearch(&#123; city:\"北京市\", // 搜索范围的城市 type:\"风景名胜\", // 搜索类型 map:map, // 可选，AMap示例 panel:\"result\", // 可选，结果列表的HTML容器id或容器元素 pageSize:5, // 结果，单页展示结果数 pageIndex:2, // 结果，页码 extensions:\"all\" // 信息，默认值 \"base\", 详细信息 \"all\" &#125;);&#125;); 根据关键字搜索 1234// 关键字搜索s1.search(\"八达岭\",function (status,result) &#123; console.log(result);&#125;); 预览 image 根据中心点经纬度、半径以及关键字进行周边查询（周边搜索） 1234// 周边搜索s1.searchNearBy(\"餐饮\",[116.403322, 39.920255],1000,function (status,result) &#123; console.log(result); &#125;); 预览 image 根据范围和关键词进行范围查询 123var lnglat1=new AMap.LngLat( 116.403322, 39.920255);var lnglat2=new AMap.LngLat( 116.389846, 39.891365);s1.searchInBounds('酒店',new AMap.Bounds(lnglat1,lnglat2)); 预览 image 根据POIID 查询POI详细信息 POIID是返回数据（JSON）的一个 id 值 image 获取POI的详细信息 1234s1.getDetails(\"B000A82RP2\",function (status,result) &#123; console.log(result.poiList.pois[0].name); window.top.data=result.poiList.pois[0]; &#125;); 预览 image 公交线路搜索插件 AMap.LineSearch 创建公交线路查询类的实例 123456AMap.service(\"AMap.LineSearch\",function () &#123; var lineSearch=new AMap.LineSearch(&#123; city:\"太原\", extensions:\"all\" &#125;); &#125;); 按关键字查询公交线路 123456lineSearch.search(\"901\",function (status,result) &#123; if (status===\"complete\" &amp;&amp; result.info===\"OK\") &#123; console.log(result); window.top.data=result; &#125; &#125;); 预览 image 按id查询公交线路 123456lineSearch.searchById(\"140100010458\",function (status,result) &#123; if (status===\"complete\" &amp;&amp; result.info===\"OK\") &#123; console.log(result); window.top.data=result; &#125; &#125;); 预览 image LineInfo 对象 基本信息 属性类型说明idString公交线路id，该id是唯一标识nameString公交线路名称pathArray.&lt;LngLat&gt;公交线路经纬度citycodeString公交线路所在城市的城市编码typeString公交类型列表typeString公交类型列表start_stopString首发站end_stopString终点站 详细信息 属性类型说明stimeString首班车时间etimeString末班车时间basic_priceString起步票价，单位：元total_priceString全程票价，单位：元via_stopsString途径站，包括首发站和终点站distanceNumber全程距离，单位：千米boundsBounds此公交路线的地理范围companyString所属公交公司 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（四）","date":"2017-02-22T11:03:02.000Z","path":"2017/02/22/高德地图 Javascript API 入门（四）/","text":"高德地图 Javascript API 入门（四）地图覆盖物覆盖物类名说明是否插件AMap.Marker点标记否AMap.Icon覆盖物&gt;点标记&gt;复杂点标记对象，对普通点标记Marker 的扩展否AMap.Polyline覆盖物&gt;折线否AMap.Polygon覆盖物&gt;多边形否AMap.Circle覆盖物&gt;圆否AMap.GroundImage图片覆盖物否AMap.ContextMenu地图右键菜单否 点标记JS 1234var marker=new AMap.Marker(&#123; map:map, position:new AMap.LngLat(112.736465,37.696495)&#125;); 预览 iamge 自定义点标记 JS 12345678910111213141516171819var marker=new AMap.Marker(&#123; map:map, position:new AMap.LngLat(112.736465,37.696495), icon:new AMap.Icon(&#123; image:\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2803620233,1906638381&amp;fm=23&amp;gp=0.jpg\", size:[72,72], imageSize:[36,36] &#125;), draggable:true, raiseOnDrag:true, shape:new AMap.MarkerShape(&#123; type:\"circle\", coords:[112.736465,37.696495,100] &#125;), label:&#123; content:\"label\", offset:new AMap.Pixel(0,-36) &#125;&#125;); 预览 image 多边形JS 12345678910var lineArr=[ [112.49157,37.897392], [112.602806,37.898747], [112.608643,37.797355], [112.49775,37.79627]];var polygon=new AMap.Polygon(&#123; map:map, path:lineArr&#125;); 预览 image 右键菜单JS 1234567891011121314151617181920var contextmenu=new AMap.ContextMenu();var pos=[];// 添加右键菜单内容项contextmenu.addItem(\"放大\",function () &#123; map.zoomIn();&#125;,0);contextmenu.addItem(\"缩小\",function () &#123; map.zoomOut();&#125;,1);contextmenu.addItem(\"添加点标记\",function () &#123; var marker=new AMap.Marker(&#123; map:map, position:pos &#125;);&#125;,2);// 监听鼠标右击事件map.on(\"rightclick\",function (e) &#123; contextmenu.open(map,e.lnglat); pos=e.lnglat;&#125;); 预览 image 信息窗体信息窗体JS 123456789var infowindow=new AMap.InfoWindow(&#123; isCustom:false, content:\"&lt;h3&gt;Hello,Yuanping&lt;/h3&gt;\", offset:new AMap.Pixel(0,-36), showShadow:true, closeWhenClickMap:true, autoMove:true&#125;);infowindow.open(map,new AMap.LngLat(112.736465,38.696495)); 预览 image 小练习鼠标划过山西大剧院时，弹出信息窗体JS 123456789101112131415161718192021222324252627282930313233343536373839404142// 坐标var lineArr=[ [112.532802,37.808395], [112.533049,37.808395], [112.533124,37.808476], [112.533521,37.808459], [112.533558,37.808391], [112.533832,37.808391], [112.533848,37.80792], [112.534159,37.807959], [112.534159,37.80748], [112.533826,37.807514], [112.533832,37.807179], [112.533966,37.806848], [112.533376,37.806683], [112.533054,37.806687], [112.532684,37.806878], [112.53278,37.807191], [112.532796,37.80745], [112.532013,37.807285], [112.532019,37.808213], [112.532796,37.808018], [112.532818,37.808412]];// 实例化Polygon类var polygon=new AMap.Polygon(&#123; map:map, path:lineArr&#125;);// 适应窗口map.setFitView();// 实例化信息窗体类var infowindow=new AMap.InfoWindow(&#123; content:\"&lt;h3&gt;太原市&lt;/h3&gt;&lt;p&gt;山西大剧院&lt;/p&gt;\", closeWhenClickMap:true&#125;);// 监听鼠标移入、移除事件polygon.on(\"mouseover\",function (e) &#123; infowindow.open(map,map.getCenter());&#125;).on(\"mouseout\",function () &#123; infowindow.close();&#125;); 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（三）","date":"2017-02-22T04:52:44.000Z","path":"2017/02/22/高德地图 Javascript API 入门（三）/","text":"高德地图 Javascript API 入门（三）距离测量插件区别虽然鼠标工具插件也提供距离量测功能，但是距离量测插件，提供更为丰富的样式设置功能。 加载插件JS 1234map.plugin([\"AMap.RangingTool\"],function () &#123; var rangingTool=new AMap.RangingTool(map); rangingTool.turnOn(); // 开启量测功能&#125;); 预览 image 样式设置RangingToolOptions类型说明startMarkerOptionsObject设置量测起始点标记属性对象，包括点标记样式、大小等，参考 &nbsp;&nbsp;MarkerOptions &nbsp;列表midMarkerOptionsObject设置量测中间点标记属性对象，包括点标记样式、大小等，参考 &nbsp;MarkerOptions &nbsp;列表endMarkerOptionsObject设置量测结束点标记属性对象，包括点标记样式、大小等，参考 &nbsp;MarkerOptions &nbsp;列表lineOptionsObject设置距离量测线的属性对象，包括线样式、颜色等，参考 &nbsp;PolylineOptions 列表tmpLineOptionsObject设置距离量测过程中临时量测线的属性对象，包括线样式、颜色等，参考 &nbsp;PolylineOptions &nbsp;列表startLabelTextString设置量测起始点标签的文字内容，默认为“起点”midLabelTextString设置量测中间点处标签的文字内容，默认为当前量测结果值endLabelTextString设置量测结束点处标签的文字内容，默认为当前量测结果值startLabelOffsetPixel&nbsp;设置量测起始点标签的偏移量。默认值：Pixel(-6, 6)midLabelOffsetPixel&nbsp;设置量测中间点标签的偏移量。默认值：Pixel(-6, 6)endLabelOffsetPixel&nbsp;设置量测结束点标签的偏移量。默认值：Pixel(-6, 6) 示例改变标签文字JS 12345678map.plugin([\"AMap.RangingTool\"],function () &#123; var rangingTool=new AMap.RangingTool(map,&#123; startLabelText:\"START\", midLabelText:\"MID\", endLabelText:\"END\" &#125;); rangingTool.turnOn();&#125;); 预览 image 改变线条样式JS 1234567891011121314map.plugin([\"AMap.RangingTool\"],function () &#123; var rangingTool=new AMap.RangingTool(map,&#123; lineOptions:&#123; strokeColor:\"#ff3300\", strokeStyle:\"dashed\", strokeWeight:10, strokeOpacity:0.5, isOutline:true, outlineColor:\"#009933\", showDir:true &#125; &#125;); rangingTool.turnOn();&#125;); 预览 image 小练习绘制太原市区的大概范围JS 1234567891011121314151617181920212223242526// 用坐标拾取器获得坐标var lineArr=[ [112.490931,37.898793], [112.553588,37.898793], [112.603026,37.899877], [112.605086,37.855028], [112.605601,37.831169], [112.610236,37.824661], [112.610236,37.798487], [112.602683,37.793739], [112.499171,37.793739], [112.495051,37.794553], [112.500544,37.830762], [112.500716,37.843099], [112.48973,37.847301], [112.489901,37.896897], [112.492476,37.8992]];// 实例化一个Polyline类var polyline=new AMap.Polyline(&#123; path:lineArr, strokeColor:\"#ff2200\", strokeWeight:5&#125;);// 添加到地图中polyline.setMap(map); 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（二）","date":"2017-02-21T05:53:12.000Z","path":"2017/02/21/高德地图 Javascript API 入门（二）/","text":"高德地图 Javascript API 入门（二）鼠标工具插件测量距离JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.rule();&#125;); 预览 image 测量面积JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.measureArea();&#125;); 预览 image 绘制点标注JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.marker();&#125;); 预览 image 绘制折线JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.polyline();&#125;); 预览 image 绘制多边形JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.polygon();&#125;); 预览 image 绘制矩形JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.rectangle();&#125;); 预览 image 绘制圆JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.circle();&#125;); 预览 image 全部功能方法返回值说明marker( options：MarkerOptions)&nbsp;开启鼠标画点标注模式。鼠标在地图上单击绘制点标注，标注样式参考MarkerOptions设置polyline( options：PolylineOptions)开启鼠标画折线模式。鼠标在地图上点击绘制折线，鼠标左键双击或右键单击结束绘制，折线样式参考PolylineOptions设置polygon( options：PolygonOptions)开启鼠标画多边形模式。鼠标在地图上单击开始绘制多边形，鼠标左键双击或右键单击结束当前多边形的绘制，多边形样式参考PolygonOptions设置rectangle( options：PolygonOptions)开启鼠标画矩形模式。鼠标在地图上拉框即可绘制相应的矩形。矩形样式参考PolygonOptions设置circle( options：CircleOptions)开启鼠标画圆模式。鼠标在地图上拖动绘制相应的圆形。圆形样式参考CircleOptions设置rule( options：PolylineOptions)开启距离量测模式。鼠标在地图上单击绘制量测节点，并计算显示两两节点之间的距离，鼠标左键双击或右键单击结束当前量测操作。量测线样式参考 PolylineOptions 设置注：不能同时使用rule方法和RangTool插件进行距离量测measureArea( options：PolygonOptions)开启面积量测模式。鼠标在地图上单击绘制量测区域，鼠标左键双击或右键单击结束当前量测操作，并显示本次量测结果。量测面样式参考PolygonOptions设置rectZoomIn( options：PolygonOptions)开启鼠标拉框放大模式。鼠标可在地图上拉框放大地图。矩形框样式参考PolygonOptions设置rectZoomOut( options：PolygonOptions)开启鼠标拉框缩小模式。鼠标可在地图上拉框缩小地图。矩形框样式参考PolygonOptions设置close( Boolean)关闭当前鼠标操作。参数arg设为true时，鼠标操作关闭的同时清除地图上绘制的所有覆盖物对象；设为false时，保留所绘制的覆盖物对象。默认为false 自定义覆盖物样式以折线为例 Polyline JS 123456789map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.polyline(&#123; strokeColor:\"#f50\", // 线条颜色，十六进制 strokeOpacity:0.5, // 线条透明度 strokeWeight:10, // 线条宽度 strokeStyle:\"dashed\" // 线条样式 solid || dashed &#125;);&#125;); 更多详细参数参考 http://lbs.amap.com/api/javascript-api/reference/overlay#PolylineOptions 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（一）","date":"2017-02-20T11:32:00.000Z","path":"2017/02/20/高德地图 Javascript API 入门（一）/","text":"高德地图 Javascript API 入门（一）准备工作首先注册个开发者账号 image 然后创建应用，获取Key image 新建HTML文件，在body标签中引入如下代码（把你的Key值填入即可）HTML 1&lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值\"&gt;&lt;/script&gt; 创建设置地图容器HTML 1&lt;div id=\"container\"&gt;&lt;/div&gt; CSS 1#container &#123;width:300px; height: 180px; &#125; 地图初始化创建地图JS 1var map = new AMap.Map('container'); 设置地图参数可以通过以下设置JS 1234var map = new AMap.Map('container',&#123; zoom: 12, center: [112.549248,37.852135]&#125;); 也可通过map对象的方法设置 JS 123var map = new AMap.Map('container');map.setZoom(12);map.setCenter([112.549248,37.852135]); 预览 高德地图 个性化地图改变地图样式目前支持五种地图配色模版 地图类型列表 名称说明normal默认样式dark深色样式blue_night夜空蓝样式fresh浅色样式lightosm清新风格样式 可以这样设置JS 12345var map = new AMap.Map('container', &#123; resizeEnable: true, mapStyle:'fresh', center: [116.408075, 39.950187] &#125;); 也可以这样设置JS 1map.setMapStyle(\"fresh\"); 预览 image 显示指定地图内容（地图要素）名称说明bg背景地图point兴趣点road道路building建筑 JS 12map.setFeatures(\"road\");//单一种类要素显示map.setFeatures(['road','point'])//多个种类要素显示 预览（只显示道路要素的地图） image 地图控件JavaScript API提供了工具条、比例尺、定位、鹰眼、基本图层切换等常用的控件 名称类名简介工具条ToolBar集成了缩放、平移、定位等功能按钮在内的组合控件比例尺Scale展示地图在当前层级和纬度下的比例尺定位Geolocation用来获取和展示用户主机所在的经纬度位置鹰眼OverView在地图右下角显示地图的缩略图类别切换MapType实现默认图层与卫星图、实施交通图层之间切换的控 添加控件 JS 123map.plugin([\"AMap.ToolBar\"],function () &#123; map.addControl(new AMap.ToolBar()); // 工具条控件&#125;); （其他控件添加方式同上） 预览（带有工具条控件的地图） image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"HTML+CSS+JAVASCRIPT 网易云音乐播放器","date":"2017-02-18T12:15:55.000Z","path":"2017/02/18/网易云音乐播放器/","text":"HTML+CSS+JAVASCRIPT 高仿低配网页版网易云音乐播放器 image image image 写在前头的话鄙人野生前端一只，gis专业，自学前端已经一年多了，为什么要写个音乐播放器呢？原因有两个： 本人是网易云音乐的重度用户，近乎疯狂 自学了前端这么久了，也是想检验下自己的成果吧 本播放器要干什么呢 简单的 播放 暂停 那当然不能少 切换歌曲，上一首 、 下一首 也得有 进度条 ，这个有点复杂，本来想用 input[range] 写，但是样式不好改，自己用多个div代替吧 进度条都有了，音量调节 不能少吧，毕竟他俩UI样式差不多，照猫画虎呗 再加一个 静音功能 ，省的音乐太大声，邻居找茬哦(⊙o⊙) 本播放器还能干什么呢 歌词滚动 有木有 搜索单曲 指定歌单播放 这个需要知道歌单的 id 不是很好找，（得上网易云音乐官网登录自己的账号，找到歌单，点进去，抬头看URL 里最后的 id 参数）暂时用的是“我喜欢的音乐”（歌单）的id 那闲话不多说，开整吧（原谅一个理科生的表达能力）我模仿的是网易云音乐的PC端，所用到的技术都是前端的基本技术 HTML、CSS、JAVASCRIPT由于我是自学的，没有那么多规矩，我这个人看到是我感兴趣的，我立马就会去做，这个播放器也不例外。 首先先的将它“画”出来（HTML+CSS） 我仔细看了下网易云音乐PC端的布局，大致分为四部分，四个模块 顶部菜单（顶部导航，叫什么名无所谓了） 底部播放条 这是播放器的核心 主体内容在右边 歌单的详细信息和歌曲列表 左侧是导航和歌单组 左下角还有一个小窗，显示正在播放歌曲的简要信息，点击小窗 展开一个歌曲详情页 无图不真相 image 然后呢，写页面逻辑JavaScript 播放器 播放器的控制按钮播放(暂停)按钮，这个可以通过play()和pause()方法实现 进度条这个通过监听timeupdate事件，实施更新当前播放位置，通过监听鼠标移动事件，改变进度条的长度 静音按钮，可以通过audio.muted=true实现 初始化歌单列表网易云音乐获取歌单的APIhttp://music.163.com/api/playlist/detail?id=[id] id 歌单id 因为涉及到跨域问题。暂时我前台这边又没有办法跨域，所以参考了网上的代码，写个PHP做代理，这样就不存在跨域问题了。获取到歌单数据后，重新渲染下DOM 搜索歌曲网易云音乐获取歌曲的APIhttp://s.music.163.com/search/get?s=[songname]&amp;type=1&amp;limit=10 s 搜索内容 type 搜索类型 limit 搜索返回结果数 歌曲详情页主要是歌词和歌词滚动 网易云音乐获取歌词APIhttp://music.163.com/api/song/lyric?os=pc&amp;id=[id] id 歌曲id 歌词滚动，先把获取到的歌词数据分割成时间点和歌词两部分，将这两部分存入dataset中，通过监听timeupdate事件，判断和当前播放时间相近的歌词，记录它的getBoundingClient()的top值，将滚动条设置到指定位置 例如：ele.srcollTop=100; 先写到这里吧总结能力太差了，原谅理科生的无奈","tags":[{"name":"前端","slug":"前端","permalink":"http://yangfan.site/tags/前端/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"http://yangfan.site/tags/音乐播放器/"}]},{"title":"教你快速搭建个人博客","date":"2017-02-03T12:15:55.000Z","path":"2017/02/03/教你快速搭建个人博客/","text":"基于HEXO博客框架和Github搭建个人博客简单教程Author: YangfanTime: 2017-02-03 准备工作 配置环境 安装Node.js安装Git注册GitHub Hexo 部分 Hexo简介Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 hexo Hexo安装方法参考官网中文文档,只需要一条命令即可自动安装hexo框架。$ npm install -g hexo-cli #使用 npm 安装 Hexo 初始化创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：hexo init 生成静态页面继续再Blog目录下执行如下命令，生成静态页面hexo generate （或者 hexo g） 本地启动启动本地服务，进行文章预览调试，命令：hexo server 本地测试浏览器输入 http://localhost:4000 Github 部分 注册githubGithub 新建仓库建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!! 本地_config.yml文配置件，建立关联我们需要_config.yml文件，来建立关联(注意冒号后面要有空格) 12345deploy: type: git repository: https://github.com/leopardpan/ leopardpan.github.io.git branch: master 部署 执行如下命令才能使用git部署npm install hexo-deployer-git --save(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。) 执行配置命令：hexo deploy然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了 发文章 每次部署的步骤，可按以下三步来进行。 1234hexo clean hexo generate hexo deploy 一些常用命令： 12345678hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 参考： http://www.jianshu.com/p/465830080ea9 http://www.chinaz.com/web/2016/0105/491998.shtml","tags":[{"name":"博客","slug":"博客","permalink":"http://yangfan.site/tags/博客/"},{"name":"建站","slug":"建站","permalink":"http://yangfan.site/tags/建站/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yangfan.site/tags/Hexo/"}]}]