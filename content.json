[{"title":"一次 bug 的寻找之旅","date":"2019-04-17T06:17:36.000Z","path":"2019/04/17/一次-bug-的寻找之旅/","text":"一次 bug 的寻找之旅前言在最近的一个项目中，用到了 ant-design 的 轮播图组件 Carousel，发现无法按照预期给每个 slide 加样式（内联样式），后来发现是 ant-design 的轮播图组件引用的三方库 react-slick，通过源码查找，终于发现是代码把内联样式重写了 情景再现按照 ant-design 的官方示例，把demo拷贝过来 123456789101112131415import &#123; Carousel &#125; from 'antd';function onChange(a, b, c) &#123; console.log(a, b, c);&#125;ReactDOM.render( &lt;Carousel afterChange=&#123;onChange&#125;&gt; &lt;div&gt;&lt;h3&gt;1&lt;/h3&gt;&lt;/div&gt; &lt;div&gt;&lt;h3&gt;2&lt;/h3&gt;&lt;/div&gt; &lt;div&gt;&lt;h3&gt;3&lt;/h3&gt;&lt;/div&gt; &lt;div&gt;&lt;h3&gt;4&lt;/h3&gt;&lt;/div&gt; &lt;/Carousel&gt;, mountNode); 一切正常。然后按业务改动代码，加入背景图 123456789101112import urlBg001 from \"./images/urlBg001.png\";import urlBg002 from \"./images/urlBg002.png\";import urlBg003 from \"./images/urlBg003.png\";ReactDOM.render( &lt;Carousel afterChange=&#123;onChange&#125;&gt; &lt;div style=&#123;&#123; backgroundImage: `url($&#123;urlBg001&#125;)` &#125;&#125;&gt;&lt;h3&gt;1&lt;/h3&gt;&lt;/div&gt; &lt;div style=&#123;&#123; backgroundImage: `url($&#123;urlBg002&#125;)` &#125;&#125;&gt;&lt;h3&gt;2&lt;/h3&gt;&lt;/div&gt; &lt;div style=&#123;&#123; backgroundImage: `url($&#123;urlBg003&#125;)` &#125;&#125;&gt;&lt;h3&gt;3&lt;/h3&gt;&lt;/div&gt; &lt;/Carousel&gt;, mountNode); 然而，没有任何效果（不显示背景图） 思考问题所在为何会这样呢 首先，我以为是图片路径的问题，做了个验证，发现图片正常显示 1234567ReactDOM.render( &lt;Carousel afterChange=&#123;onChange&#125;&gt; &lt;div&gt;&lt;img src=&#123;urlBg001&#125; /&gt;&lt;/div&gt; &lt;/Carousel&gt;, mountNode); 然后，我就怀疑是不是 Carousel 这个组件对插槽做了限制，进行了进一步的验证 123456789101112ReactDOM.render( &lt;Carousel afterChange=&#123;onChange&#125;&gt; &lt;div id=\"test-slide\" style=&#123; &#123; backgroundImage: `url($&#123;urlBg001&#125;)`, color:\"#f02\", width:\"50px\", &#125;&#125;&gt;1&lt;/div&gt; &lt;/Carousel&gt;, mountNode); 结果，没有任何效果，打开控制台，找到 id 是 test-slide 的那个元素，发现渲染的结果是下面这样： 1&lt;div id=\"test-slide\" tabindex=\"-1\" style=\"width: 100%; display: inline-block;\"&gt;1&lt;/div&gt; style 属性被重写了，我自己加的 style 不见了，更加确信了是 Carousel 组件内部搞的鬼 打开 github 扒 ant-design 源码，没有发现对 style 属性做任何更改，然后在头部找到该组件其实是引入一个 react-slick，然后包装了下 12345678910111213141516171819// https://github.com/ant-design/ant-design/blob/master/components/carousel/index.tsx#L23const SlickCarousel = require(&quot;react-slick&quot;).default;export default class Carousel extends React.Component&lt;CarouselProps, &#123;&#125;&gt; &#123; // 部分代码省略 ... renderCarousel = (&#123; getPrefixCls &#125;: ConfigConsumerProps) =&gt; &#123; // 部分代码省略 ... return ( &lt;div className=&#123;className&#125;&gt; &lt;SlickCarousel ref=&#123;this.saveSlick&#125; &#123;...props&#125; /&gt; &lt;/div&gt; ); &#125;; render() &#123; return &lt;ConfigConsumer&gt;&#123;this.renderCarousel&#125;&lt;/ConfigConsumer&gt;; &#125;&#125; 真相慢慢的付出了水面，再次扒 react-slick 的源码，终于功夫不负有心人，在这个文件里发现了问题的源头 12345678910// https://github.com/akiran/react-slick/blob/master/src/slider.js#L184React.cloneElement(children[k], &#123; key: 100 * i + 10 * j + k, tabIndex: -1, style: &#123; width: `$&#123;100 / settings.slidesPerRow&#125;%`, display: \"inline-block\" &#125;&#125;) 直接将子元素children 的 style 属性覆盖了 最后在 react-slick 找到了相关 issue，然额这个 issue 仍然是 open 状态 在 PR 中找到 pull#1372，有人尝试修复过，但是 PR 又关了，不知道什么原因 解决方案由于不知道源码作者为何要这么设置，我只能先找其他方法解决 方法一多嵌套一层，只要不是在第一层元素上操作就行 12345678ReactDOM.render( &lt;Carousel&gt; &lt;div&gt; &lt;div style=&#123;&#123; backgroundImage: `url($&#123;logo&#125;)` &#125;&#125;&gt;1&lt;/div&gt; &lt;/div&gt; &lt;/Carousel&gt;, mountNode); 方法二 用其他方式达成目的 123456ReactDOM.render( &lt;Carousel&gt; &lt;img src=&#123;logo&#125; alt=\"001\"/&gt; &lt;/Carousel&gt;, mountNode); 总结 找这个 bug 还是挺费时间的，不过，通过这次 bug 之旅，学到一定要用科学的方法，精准定位问题来源，多做空白试验参照，进行对比，这样才能更快的解决问题 一定要多看源码，可以学到很多技巧 备注可以点击下面的链接查看 “情景重现” 和组件源码 “情景重现”demo https://codesandbox.io/s/92n1x0w1my 源码ant-design https://github.com/ant-design/ant-design/blob/master/components/carousel/index.tsx#L23react-slick https://github.com/akiran/react-slick/blob/master/src/slider.js#L185","tags":[]},{"title":"【译】React 函数式组件和 React 类有何不同","date":"2019-04-07T06:16:44.000Z","path":"2019/04/07/【译】React-函数式组件和-React-类有何不同/","text":"React 函数式组件和 React 类有何不同？ 原文地址：https://overreacted.io/how-are-function-components-different-from-classes/ 原文作者：Dan Abramov Markdown 地址：https://github.com/gaearon/overreacted.io/edit/master/src/pages/how-are-function-components-different-from-classes/index.md 译者：Yangfan2016 英文版权所有：Dan Abramov 一段时间内，权威的答案是 “类” 可以提供更多的特性的访问（比如，state）。而 Hooks 就不一样了 或许你已了解到一种最佳实践。哪一种内？大多数基准测试都不完美，因此我得小心谨慎从它们中得出结论。性能本质上取决于代码做了什么而不是你选择函数还是类。我们观察到，它们的性能差别微不足道，尽管优化策略有些不同 无论哪种情况下，我们都不推荐重写你已存在的组件，除非你有其他原因，和不介意做第一个 “吃螃蟹” 的人。Hooks 仍然是新概念（就像 2014 年的 React），并且那些 “最佳实践” 至今都没有在教程里找到 那么给我们留下了什么内？React 函数和类有本质的区别吗？当然，它们有（在心智模型层面上）。这篇文章，我将找到它们之间的最大的不同。 它自从 2015 的函数式组件被引入就存在了，但是它经常被忽视： 函数式组件捕获已渲染的值 让我们拆开这个概念来理解 注意：这篇文章并不做类或函数的价值评判。我只是描述下这两种编程模式在 React 中的不同。更多采用函数式的问题，请查阅 Hooks FAQ 仔细看看这个组件： 12345678910111213function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert('Followed ' + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 它会显示一个用 setTimeout 模拟网络请求的按钮，并且之后会显示一个确认框。例如，如果 props.user 的值是 &#39;Dan&#39;，那么在 3 秒之后会显示 &#39;Followed Dan&#39;。足够简单 （注意，在这个例子中，不论我使用箭头函数还是声明式函数都没有关系。function handleClick() 都会以相同的方式正确执行） 我们如何用 “类” 重写内？原生翻译看起来可能是这样的： 12345678910111213class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert('Followed ' + this.props.user); &#125;; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 通常认为这两个代码片段是等价的。人们总是在这些模式进行自由的重构，而从来没有注意到它们的意义： 找出两个版本的不同 然而，这两个代码片段只有细微的差别。 仔细看看它们，你发现不同了吗？就我个人而言，我花了一些时间才找到 前方剧透，如果你要自己弄明白的话，请看这个在线 demo ，文章的剩下的部分都在解释它们的差别和为何它如此重要 在继续之前，我想强调下这篇文章描述的区别和 React Hooks 半毛钱关系都没有。甚至上面的例子里都没有提及 Hooks！ 文章都是关于 React 中所有函数和 “类” 的差异。如果你计划在 React app 中更频繁的使用函数，你可能更想理解它 我们将用一个 React 应用中常见的 “类” bug 来图解这个区别 打来这个 sandbox 例子，有一个简介选择器和两个 信息页面（每个都有一个关注按钮） 试着按下面的顺序触发这两个按钮： 单击 其中一个关注按钮 在 3 秒过去之前 改变 已选的简介 读取 警告框的内容 你会发现一个奇怪的差异： 使用上面的 function 信息页面 ，点击关注 Dan 的简介后，然后导航到 Sophie 的简介依然弹框显示 &#39;Followed Dan&#39; 使用上面的 class 信息页面 ，它会弹框显示 &#39;Followed Sophie&#39;： 步骤示范 在这个例子中，第一个行为是正确的。如果我关注了一个人，然后导航到另一个人的简介页面，我的组件不应该困惑我到底关注了谁。 这个 “类” 实现明显是个 bug （虽然你完全可以这样关注 Sophie） 那么为何我们的 “类” 例子会如此表现内？ 让我们仔细看看我们 “类” 方法 showMessage： 1234class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + this.props.user); &#125;; 这个 “类” 方法从 this.props.user 读取。Props 在 React 里是不可变的，因此它们永远也不会改变。然而，this 是，总是多变的 事实上，这就是 “类” 里 this 的全部目的。React 自己会随着时间改变，以至于你可以在 render 和生命周期方法获取到最新的版本 因此如果我们在请求期间重新渲染我们的组件，this.props 会改变。showMessage 方法获取到 user 将是 “更新的” props 这个例子揭露出一个关于用户界面本质的有趣的观察。如果我们说 UI 概念上是当前应用状态的函数，那么事件处理器就是渲染结果的一部分（就像可视化输出一样）。我们事件处理器 “属于” 一个拥有特定 props 和 state 的特定渲染 然而，这些回调读取 this.props 超时会断开这个联系。我们的 showMessage 回调不能 “绑” 到任何特定的渲染，那么它就会 “丢失” 正确的 props。读取 this 的链接就会被切断 我们假设函数式组件不存在。 我们该如何解决这个问题内？ 我们想以某种方式 “修复” 带着正确的 props 的 render 和 showMessage 回调读取它们的联系。在某个地方，props 可能会丢失 一种方式是在事件处理更早读取 this.props，并且显示通过超时完成处理器传递进去： 1234567891011121314class ProfilePage extends React.Component &#123; showMessage = (user) =&gt; &#123; alert(&apos;Followed &apos; + user); &#125;; handleClick = () =&gt; &#123; const &#123;user&#125; = this.props; setTimeout(() =&gt; this.showMessage(user), 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 起作用了。然而，这种方式随着时间变化显著造成代码更冗余和容易出错。如果我们需要不止一个 prop？如果我们也需要访问这个 state？如果 showMessage 调用其他方法，而且这个方法也需要读取 this.props.something 或 this.state.something，我们又遇到了同样的问题。 因此我们把 this.props 和 this.state 作为参数从 showMessage 传递给每个它调用的方法 这么做会破坏 “类” 正常提供的工程学。它也难以记住和执行，这就是为何人们常常满足于 bug 的原因 同样，在 handleClick 里内嵌 alert 代码并不能解决更大的问题。我们想用一种方式结构化代码允许被更多方法拆分，但是 还是要读取调用相应渲染的 props 和 state。这个问题甚至都不是 React 独有的（你可以把这个可变对象如 this，放到任何一个 UI 库里都可以重现） 或许，我们可以在构造器中 绑定 这个方法？ 12345678910111213141516171819class ProfilePage extends React.Component &#123; constructor(props) &#123; super(props); this.showMessage = this.showMessage.bind(this); this.handleClick = this.handleClick.bind(this); &#125; showMessage() &#123; alert(&apos;Followed &apos; + this.props.user); &#125; handleClick() &#123; setTimeout(this.showMessage, 3000); &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 不，它不会解决任何问题。记住，问题所在是我们读取 this.props 太迟了（不是我们使用的语法有错！）然而，如果我们完全依赖 JavaScript 闭包可以解决这个问题 闭包总是被回避，因为它难以理解，值会随着时间变化。但是在 React 中，props 和 state 是不可变的！（或者至少，它是强烈推荐）消除了闭包的主要阻碍 这意味着如果你在一个特别的渲染遮蔽了 props 或 state，你总是可以指望它们完全相同： 123456789101112131415161718class ProfilePage extends React.Component &#123; render() &#123; // 捕获这个 props！ const props = this.props; // 注意：我们在 *render 内部*。 // 这些不是类方法 const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 你已经捕获了渲染时的 props： 捕捉口袋妖怪 这种方法，任何代码内置在它里面（包含在 showMessage 里），保证看到特定渲染的 props。React 不再 “移动我们的奶酪” 我们可以在里面添加我们想要的任何数量的辅助函数，并且它们都将使用捕获的 prop 和 state。 闭包营救了我们！ 上面这个例子是对的，但是看起来有点怪，如果你在 render 里定义了函数而不是使用 “类” 方法，那么在 “类” 里这么做有什么意义内？ 事实上，我们可以通过移除它周围的 “壳” 来简化代码： 12345678910111213function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert('Followed ' + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 就像上面这样，props 依然可以被捕获（React 把它们作为参数传递进去）。不像 this，props 对象永远不可能因 React 而发生改变 如果你把函数定义里的 props 解构的话，会更清晰： 12345678910111213function ProfilePage(&#123; user &#125;) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 当父组件携带不同的 props 渲染 ProfilePage 时，React 会再次调用 ProfilePage 函数。但是我们已经点击 “属于” 前一次渲染它自己的 user 的值和读取 showMessage 回调的那个事件处理程序。它们都原封不动 这就是为何在这个版本的 demo 函数中，点击关注 Sophie 的简介和改变选项到 Sunil 依然弹出 &#39;Followed Sophie&#39;： 正确行为的 demo 这个行为是对的。（尽管你可能也想关注 Sunil） 现在我们就理解了 React 中 “类” 和函数的最大差别： 函数式组件捕获已渲染的值 对于 Hooks，同样的原则也适用于 state。 仔细看看下面这个例子： 12345678910111213141516171819202122function MessageThread() &#123; const [message, setMessage] = useState(''); const showMessage = () =&gt; &#123; alert('You said: ' + message); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = (e) =&gt; &#123; setMessage(e.target.value); &#125;; return ( &lt;&gt; &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125; （这里有一个在线 demo） 虽然这个消息 app UI 并不是很好，但它阐述了相同的原理：如果我发送了一个特别的消息，那么组件不应该困惑发送出去的消息实际是什么。这个函数组件的 message 捕获了 “属于” 返回浏览器调用的点击处理程序的渲染的 state。因此，message 被设置为我点击 “发送” 那一时刻的输入框的值 因此我们了解到 React 的函数默认捕获 props 和 state。但是如果 想 读取到最新的不是属于这个特定渲染的 props 或 state？ 假如我们想从未来读取它们？ 在 “类” 中，你可以通过 this.props 或 this.state 读取到，因为 this 本身是可变的。React 改变了它。在函数式组件里，你也可以拥有一个可变值，该值由所有组件渲染器共享。它称为 “ref”： 12345function MyComponent() &#123; const ref = useRef(null); // 你可以读取或设置 `ref.current` // ...&#125; 然而，你需要自己管理它 一个 ref 扮演者和一个实例字段相同的角色。它是进入可变命令式世界的转义口。你或许对 “DOM refs” 很熟悉，但是这个概念更宽泛。它就像你放东西的盒子一样 即使在视觉上，this.something 看起来像是 something.current 的镜像。它们代表相同的概念 默认情况下，React 不会为了在函数式组件的最新 props 或 state 创建 refs。大多数情况下你不需要它们，而且给它们赋值会浪费工作。然而，如果你喜欢的话，可以手动跟踪这个值： 12345678910111213141516function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); const latestMessage = useRef(&apos;&apos;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + latestMessage.current); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = (e) =&gt; &#123; setMessage(e.target.value); latestMessage.current = e.target.value; &#125;; 如果我们在 showMessage 读取 message，我们会看到我们按下发送按钮时的那个消息。但是当我们读取 latestMessage.current 时，我们得到了最新的值（即使我们在发送按钮按下之后，仍然在打字输入） 你可以比较这两个例子的区别。ref 是一种渲染一致性的 “选择性退出” 方法，而且在某些情况下很方便 通常，你应该避免在渲染 期间 读取或设置 refs，因为它们是可变的。我们想要保持渲染的可预测性。然而，如果想要得到一个特别的 prop 或 state 的最新值，手动更新 ref 可能会非常恼火。 我们可以用这个效果实现自动化： 123456789101112function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); // 持续跟踪最新值 const latestMessage = useRef(&apos;&apos;); useEffect(() =&gt; &#123; latestMessage.current = message; &#125;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + latestMessage.current); &#125;; （这有一个demo） 我们在这个效果 内部 进行赋值，以致于 ref 值只有在 DOM 更新之后改变。这就确保了我们的改变不会打破像 [Time Slicing and Suspense] (https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)特性，它们依赖渲染中断 这样使用 ref 并不是经常必须的。捕获 props 或 state 还是使用默认最好。 然而，它可以方便处理像时间间隔和订阅类命令式 API。记住你可以像 this 一样跟踪 任何 值（prop，state 变量，整个 props 对象，或甚至一个函数） 这个模式也方便优化（例如，当 useCallback id 改变太频繁）。然而，使用 reducer通常是一个更好的解决方案。（后面的文章会提及到这个主题！） 在这篇文章中，我们已经看到了 “类” 的常见的破坏模式，而且闭包如何帮助我们修复它。然而，你可能注意到当你试图指定的依赖数组优化 Hooks 时，你可能遇到陈旧的闭包的 bug。这么说是闭包的 “锅” 喽？我不这么认为 正如我们上面看到的那样，闭包确实帮助我们 修复 了很难察觉的细微问题。同样，它们也使得在并发模式正常工作的代码更容易编写。它是有可能的，因为在组件内的逻辑遮蔽了已经渲染的正确的 props 和 state 在我目前所遇到的所有情况里，“陈旧的闭包” 的问题发生是由于假设 “函数不会发生改变” 或 ”props 总是相同的“ 造成的。事实并非如此，我希望通过这篇文章有助于澄清这一点 函数遮蔽了它们的 props 和 state（而且因此它们的 id 是如此重要）。这不是 bug，而是函数式组件的一个特性。对于 useEffect 或 useCallback 函数不应该把 “依赖数组” 排除。（正确的修复是通常用 useReducer 或 useRef 来解决上面的问题 - 我们会尽快出如何在它们之间进行选择的文档） 当我们在 React 写大多数函数时，我们需要调整我们关于优化代码 和 什么值会随着时间改变的直觉 正如 Fredrik 所说： 我目前在 hooks 发现的最好的心理规律就是 “代码就像任何值，任何时候都可能改变” 函数也不例外。它需要花费一定的时间来了解 React 学习材料的常识。它需要从 “类” 中调整一些心态。但是我希望这篇文章可以帮助你刷新你的眼光 React 函数总是会捕获它们的值（现在我们知道原因了） 微笑的皮卡丘 它们是完全不同的口袋妖怪 本文仅代表原作者个人观点，译者不发表任何观点 版权由原作者所有Copyright (c) Dan Abramov and the contributors.All rights reserved.","tags":[{"name":"翻译计划","slug":"翻译计划","permalink":"http://yangfan.site/tags/翻译计划/"}]},{"title":"Element-UI  组件 el-scrollbar 的文档","date":"2019-03-05T09:09:53.000Z","path":"2019/03/05/Element-UI-组件-el-scrollbar-的文档/","text":"Element-UI 组件 el-scrollbar 的文档前言我们在 Element-UI 的其他组件里发现，有使用这个组件，并且还不错，由于 Element-UI 官方文档并没有写到关于 el-scrollbar 的文档，所以稳定性上可能是有些问题，这里只是爬了源码，翻译了一些属性的使用，仅供参考 快速使用1234&lt;el-scrollbar&gt; &lt;li v-for=\"user in userList\" :key=\"user.id\"&gt;&#123;&#123;user.name&#125;&#125;&lt;/li&gt;&lt;/el-scrollbar&gt; 具体实例1234567891011&lt;el-scrollbar wrapClass=\"yf-container\" viewClass=\"yf-content\" wrapStyle=\"color:'#fff';fontSize:'16px';\" viewStyle=\"color:'#fff';fontSize:'16px';\" :native=\"false\" :noresize=\"true\" tag=\"ul\"&gt; &lt;li v-for=\"user in userList\" :key=\"user.id\"&gt;&#123;&#123;user.name&#125;&#125;&lt;/li&gt;&lt;/el-scrollbar&gt; 结构构成 constructor 文档Attribute 参数 说明 类型 可选值 默认值 wrapClass 可选参数，容器的样式名 string - - viewClass 可选参数，展示视图的样式名 string - - wrapStyle 可选参数，容器的样式 string - - viewStyle 可选参数，展示视图的样式 string - - native 可选参数，是否使用原生滚动 boolean - false noresize 可选参数，容器大小是否是不可变的 boolean - false tag 可选参数，渲染容器的标签 string - div 备注源码 https://github.com/ElemeFE/element/blob/dev/packages/scrollbar/src/main.js 文章 element ScrollBar滚动组件源码深入分析","tags":[]},{"title":"你所不知道的 Chrome 控制台","date":"2019-02-19T07:21:25.000Z","path":"2019/02/19/你所不知道的-chrome-控制台/","text":"你所不知道的 Chrome 控制台调试技巧前言收集了一些工作中常用到的 Chrome 调试技巧，其他大部分 Chrome 调试功能工具介绍已经在其他的很多文章中介绍到了，这里就不 DRY 了 Request blocking 阻塞请求使用这个功能可以拦截请求 大部分情况是页面执行完某个操作后，页面就重定向了（比如登录），这时就不方便调试了，下面这个工具很好的解决了这个问题 比如你想了解在页面重定向之前，发去的登录请求都做了什么，使用操作如下图所示： console-reqblock-001 Coverage 代码覆盖率可以观察到代码覆盖率，哪些是没用的，去除无用代码，较少代码体积 你需要点击下图的记录按钮进行记录，然后你需要在页面上进行一些交互操作（如点击、鼠标移入等） console-coverage-001 然后你会得到下图，红色的部分是没有用到的代码占比，绿色部分是用到的代码占比，你可以点击占比进度条，到达指定源代码区进行细致查看 console-coverage-002 Changes 变化显示更改代码的比较，你可以通过这个工具观察，你用控制台修改过的代码，就和 git 的 diff 功能类似，红色代表删除、绿色代码新增 console-changes-001 你如果点击代码里的某一行，它会打开源代码面板，你可以在这里进行修改、调试操作 console-changes-002 Snippets 代码片段一般在 console 里可以临时运行代码，但是书写格式不太友好，而且一换行就执行了（当然你可以 shift+enter 换行），这时，你又懒癌发作，不想打开代码编辑器，你可以使用 Snippets 这个工具，如下图所示： console-snippets-001 可以像代码编辑器一样书写，可以格式化代码、可以断点调试、也可以单独导出文件","tags":[]},{"title":"下载 Github 仓库的指定文件夹","date":"2019-01-23T06:44:47.000Z","path":"2019/01/23/下载-Github-仓库的指定文件夹/","text":"下载整个仓库1$ git clone https://github.com/Yangfan2016/PersonalWorks.git 下载仓库内的指定文件1234567$ git init$ git config core.sparseCheckout true # 配置$ git remote add -f origin https://github.com/Yangfan2016/PersonalWorks.git$ echo \"static-page/\" &gt;&gt; .git/info/sparse-checkout # 写入要下载的文件目录$ echo \"web-app/\" &gt;&gt; .git/info/sparse-checkout$ git pull origin master","tags":[]},{"title":"【译】深入理解 ES2015，第一趴：块作用域 let 和 const","date":"2019-01-15T09:23:17.000Z","path":"2019/01/15/【译】深入理解-ES2015，第一趴：块作用域-let-和-const/","text":"【译】深入理解 ES2015，第一趴：块作用域 let 和 const 原文地址：http://javascriptissexy.com/understanding-es2015-in-depth-part-1-block-scope-with-let-and-const/ 原文作者：Dan Wellman Markdown 地址：https://github.com/Yangfan2016/learn-translate/blob/master/2-Understanding-ES2015-In-Depth-Part-1.md 译者：Yangfan2016 ES2015 最大的特性之一就是有了一个全新的作用域。在这个章节里，我们将开始学习什么是作用域。我们将继续学习如何创建新的作用域类型，以及给我们代码带来的好处 快速了解作用域作用域描述为一个变量，函数，标识符可以被访问的区域。JavaScript 传统上有两种作用域类型：全局作用域和函数作用域，你定义变量的位置会影响其他代码是否可以访问。让我们来看一个简单的例子来阐述作用域的概念。想象一下，你的 JavaScript 文件只包含以下代码： 123456789var globalVariable = 'This is global';function globalFunction1() &#123; var innerVariable1 = 'Non-global variable 1';&#125;function globalFunction2() &#123; var innerVariable2 = 'Non-global variable 2';&#125; 在上面的代码中，我们首先声明了一个变量 globalVariable。这个语句不在函数内部，所以会自动存到全局作用域中。浏览器用 window 对象创建了一个全局作用域，除了可以用 globalVariable 访问，我们还可以通过挂在 window 对象上的 window.globalVariable 访问。我们可以在文件的任何地方访问这个变量，这两个函数的之前或之后，甚至是在函数的内部（这就是为什么我们说全局变量是 “隐藏的”，我们可以在任何地方正确的访问他们），甚至是在附在同一页面的其他 JavaScript 文件 在全局作用域里，我们定义了两个函数，globalFunction1 和 globalFunction2，就像全局变量一样，他们是 “可见的” 并且可以在这个文件的任何地方调用，也可以被同一页面的其他 JavaScript 文件调用。然而，当 JavaScript 引擎解析这些函数时，会分别创建他们自己的作用域。因吹斯听，这两个新的函数作用域被嵌套在全局作用域下，成为子作用域。这也就意味着函数内的代码可以访问全局变量，就像是和在函数 “内部的” 定义变量一样 当我们试图访问 JavaScript 里的标识符时，浏览器会首先在当前作用域中查找。如果没有找到，浏览器会在当前作用域的父作用域中查找，并且继续向上查找，直到找到这个变量，或者到达全局作用域为止。如果这个变量在全局作用域里依旧没有找到的话，那么浏览器会抛出一个 ReferenceError 错误。这种嵌套的作用域被称作作用域链，而这个检查当前作用域和父作用域的过程被称作变量查找。这种查找只会向上查找作用域链，它永远不会在它的子作用域里查找 在上面的作用域链查找方向我们得知，例子中的 innerVariable1 变量只能在 globalFunction1 函数内部被访问，innerVariable2 变量只能在 globalFunction2 函数内部被访问。innerVariable1 变量不能在 globalFunction2 函数内部或全局作用域内被访问，innerVariable2 变量也不能在 globalFunction1 函数内部或全局作用域内被访问 下面的图片是上面代码中作用域的抽象表示： js-scopes 全局作用域包含了 globalVariable 以及两个内嵌的函数作用域。每个内嵌的函数作用域又包含自己的变量，但是这些变量不能被全局作用域访问。虚线表示的是作用域链的查找方向 让我们来看下另一个简短的代码示例，彻底的了解下到目前为止我们所介绍到的作用域概念。假设 JavaScript 文件只包含如下代码： 1234567function outer() &#123; var variable1; function inner() &#123; var variable2; &#125;&#125; 在这段代码里，我们在全局作用域里声明了一个叫 outer 的函数。因为它是一个函数，所以它创建了一个函数作用域，嵌套在全局作用域下。在这个作用域下，我们又声明了一个叫 variable1 的变量和 一个叫 inner 的函数。因为 inner 也是一个函数，所以一个新的作用域又被创建了，嵌套在 outer 函数的作用域下 在 inner 函数中，我们既可以访问 variable2 也可以访问 variable1。当我们在 inner 函数中访问 variable1 时，浏览器首先会在它的作用域里查找这个变量；当这个变量没有被找到时，会继续向上在父作用域里查找（也就是 outer 函数的作用域）。代码里作用域如下图所示： js-scopes2 函数作用域可以嵌套在其他的函数作用域里，但是作用域链查找规则是一样的，因此在 inner 作用域下可以访问到 variable1 和 variable2，但是在 outer 作用域下只能访问 variable1 这个示例中的作用域链比较长，从 inner 函数延伸到 outer 函数，直到全局对象 window JavaScript 的新作用域在 JavaScript 中，一个块是由一个或多个语句用大括号包裹起来的。诸如 if，for，while 的条件表达式，都是用块基于特定的条件来执行块语句 其他流行的常见的编程语言都有块作用域，JavaScript 作用域中，直到如今却只有全局作用域和函数作用域，因此使我们变得很困惑。ES2015 在 JavaScript 新增了块作用域，对于我们的代码来说有很大的影响，并且对于那些熟悉其他编程语言的开发者来说变得更直观 块作用域意味着一个块可以创建它自己的作用域，而不是简单的存在于它最近到父级函数作用域或全局作用域下。让我们在认识块作用域是如何工作的之前，先来了解下传统上块里的 JavaScript 是如何工作的： 123456789101112function fn() &#123; var x = 'function scope'; if (true) &#123; var y = 'not block scope'; &#125; function innerFn() &#123; console.log(x, y); // function scope not block scope &#125; innerFn();&#125; var 语句是不能够创建块作用域的，即使是在块里，因此 console.log 语句可以访问到 x 和 y 变量。 fn 函数创建了一个函数作用域而且 x 和 y 变量都是可以通过作用域内的作用域链访问到 声明提升理解提升的概念是理解 JavaScript 如何工作的基础。JavaScript 有两个阶段：解析阶段（JavaScript 引擎读取所有的代码）、执行阶段（执行已解析的代码）。大多数的事情都发生在第二阶段；例如，当你使用 console.log 语句时，实际的日志消息会在执行阶段打印到控制台 然而，一些重要的事情也会在解析阶段发生，包括变量的内存分配、作用域创建。提升这个术语指的是 JavaScript 引擎在遇到标识符，如变量、函数声明时所发生到事情；当发生声明提升时，它的行为就像是把它定义的字面量提升到当前作用域的顶部。鉴于此，上面到代码示例实际会变成如下情况： 123456789101112131415function fn() &#123; var x; var y; x = 'function scope'; if (true) &#123; y = 'not block scope'; &#125; function innerFn() &#123; console.log(x, y); // function scope not block scope &#125; innerFn();&#125; 只有变量到声明会提升到它的作用域的顶部；在这个例子的 if 语句中，变量赋值依然发生在我们所赋值的地方。当然，我们到变量并不会移动，而是引擎行为表现如此，因此这样可以更好的帮助我们理解代码 除了变量，函数声明也会被提升。结果就是，从 JavaScript 引擎到角度来看，代码实际上看起来是这样的： 1234567891011121314function fn() &#123; var x; var y; function innerFn() &#123; console.log(x, y); // function scope not block scope &#125; x = 'function scope'; if (true) &#123; y = 'not block scope'; &#125; innerFn();&#125; innerFn 的声明也被提升到了它的作用域的顶部。但是，记住它仅仅是函数声明被提升了，函数调用没有被提升。上面的代码并不会报任何错，因为 innerFn 在 x 和 y 赋值之前并没有被调用 使用 let即使使用了 ES2015，var 声明也不会创建块作用域。为了创建块作用域，我们需要在块里使用 let 或 const 声明。我们一会再看 const，首先来看下 let 表面上，let 和 var（我们用它来声明变量）的行为很相似： 1234function fn() &#123; var variable1; let variable2;&#125; 在这个简单的例子中，var 和 let 声明都做了相同的事情（在 fn 创建的作用域下初始化了一个新的变量）。为了创建一个新的块作用域，我们需要在块里使用 let： 12345678910function fn() &#123; var variable1 = 'function scope'; if (true) &#123; let variable2 = 'block scope'; &#125; console.log(variable1, variable2); // Uncaught ReferenceError: variable2 is not defined&#125;fn(); 在这个代码示例中，抛出了一个引用错误（reference error）；让我们来探索下为什么会这样。fn 函数创建了一个新作用域，里面声明了变量 variable1。然后我们在 if 语句的块里，声明了变量 variable2。然而，因为我们在块里使用了 let 声明，因此一个新的块作用域在 fn 的作用域下被创建了 如果 console.log 语句也在 if 块中的话，那么它就和 variable2 在相同的作用域下了，也能够通过作用域链找到 variable1。但是因为 console.log 在外头，因此它不能访问 variable2，所以会抛出一个引用错误 块作用域和函数作用域的行为相同，但是他们是为块创建的，而不是函数 暂时性死区当一个用 var 声明的常规变量被创建时，会被提升到它的作用域的顶部，然后并初始化一个 undefined 值，这样就允许我们能够在它赋值之前引用一个\b常规变量 12console.log(x); // undefinedvar x = 10; 记住，由于存在声明提升，代码实际看起来是这样的： 123var x = undefined;console.log(x); // undefinedx = 10; 这个行为会阻止抛出引用错误 ReferenceError 用 let 声明的变量也被提升了，但重要的是，他们并不会自动初始化值 undefined，因此意味着下面的代码会产生一个错误： 12console.log(x); // Uncaught ReferenceError: x is not definedlet x = 10; 这个错误是由暂时性死区（TDZ）引起的。TDZ 存在于作用域初始化到变量声明期间。为了修复这个错误（ReferenceError），我们需要在访问它前声明它： 译者注：TDZ 123let x;console.log(x); // undefinedx = 10; TDZ 这样设计是为了使开发更容易（试图引用一个还没声明的变量通常视为一个错误，而不是故意为之），因此这个错误可以立即提醒我们 使用 const新的 const 被用来声明一个不可再次赋值的变量。它和 let 的在 TDZ 的行为非常相似，\b但是，const 变量必须初始化一个\b值 1const VAR1 = 'constant'; 从现在开始， 变量 VAR1 的值将永远是 “constant” 这个字符串。如果我们试图\b再次对它赋值，\b我们会得到一个错误： TypeError: Assignment to constant variable 如果我们试图创建一个没有初始化的 const 变量，我们将看到\b一个语法错误： SyntaxError: Missing initializer in const declaration 相似地，一个 const 变量\b不能被再次声明。如果我们试图再次用 const 声明一个相同变量时，我们将得到一个不同类型的语法错误 SyntaxError: Identifier ‘VAR1′ has already been declared 和其他编程语言一样，常量是被用来保存我们的程序在生命周期里不希望改变的值 记住 let 和 const \b都是 JavaScript \b的保留词，因此在严格模式下，是不能被用作标识符名称的（变量名，函数名等）。随着 ES2015 越来越普遍，let 和 const \b优于 var \b已形成一个共识，因为变量\b创建的作用域\b更与其他现代编程语言看齐，并且代码的行为也更好预测。\b因此，在大多数情况下尽可能的\b避免使用 var 不可变性用 const 声明的变量不能被再次赋值的，但是 const 声明的变量并不是完全不可变的。如果我们用对象或数组初始化了一个 const 变量，我们依然可以修改对象的属性和增加删除数组的元素 练习 在 for 循环里用 let 来初始化计数器变量 修复下面 const 的错误： 1234const VAR1 = 'constant';const VAR1 = 'constant2';const VAR2;VAR2 = 'constant'; 成功是通过不断的练习和知识的积累，而非智力 本文仅代表原作者个人观点，译者不发表任何观点 Markdown 文件由译者手动整理，如有勘误，欢迎指正 译文和原文采用一样协议，侵删","tags":[{"name":"翻译计划","slug":"翻译计划","permalink":"http://yangfan.site/tags/翻译计划/"}]},{"title":"快速构建一个 vue 插件","date":"2019-01-10T09:05:29.000Z","path":"2019/01/10/快速构建一个-vue-插件/","text":"碎碎念上一篇文章，我们介绍了如何构建一个 react 插件，今天我们说说如何构建 vue 插件 准备工作由于与上一篇 react 插件文章使用的是相同的结构，代码测试、持续集成及发布 npm 包也都是一个套路，这里就不再敖述。下面主要说下不同的地方，let’s start 😊 开发依赖包 123456789101112131415161718&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.0.0\", \"@babel/preset-env\": \"^7.0.0\", \"babel-loader\": \"^8.0.2\", \"chai\": \"^4.2.0\", \"coveralls\": \"^3.0.2\", \"css-loader\": \"^1.0.0\", \"jest\": \"^23.6.0\", \"style-loader\": \"^0.23.1\", \"vue\": \"^2.5.21\", \"vue-loader\": \"^15.5.0\", // 解析 SFC 文件 \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.5.21\", // vue-loader 的同步\b依赖 \"webpack\": \"^4.17.2\", \"webpack-cli\": \"^3.1.0\" &#125;,&#125; webpack 配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const path = require('path');const &#123; VueLoaderPlugin &#125; = require(\"vue-loader\");module.exports = &#123; mode: \"production\", // 生产模式 entry: &#123; // 入口 \"YanProgress\": path.resolve(__dirname, './src/index.js') &#125;, output: &#123; // 出口 path: path.resolve(__dirname, './dist'), filename: '[name].min.js', publicPath: \"./dist/\", libraryTarget: 'umd', // 按 UMD 模式打包 &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; // 模板编译过程中，编译器可以将某些特性转换为 require 调用 transformAssetUrls: &#123; video: ['src', 'poster'], source: 'src', img: 'src', image: 'xlink:href' // SVG &#125; &#125;, // 只命中src目录里的js文件，加快 Webpack 搜索速度 include: path.resolve(__dirname, \"./src\"), &#125;, &#123; test: /\\.js$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125;, ], // 只命中src目录里的js文件，加快 Webpack 搜索速度 include: path.resolve(__dirname, \"./src/\"), &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125; ] &#125;, plugins: [ // vue-loader **这个插件是必须的！**它的职责是将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块。 new VueLoaderPlugin ], resolve: &#123; // 省略文件后缀时，默认按下面的配置取 extensions: ['.js', '.vue'], &#125;, externals: &#123; // 不把 vue 打包进去 vue: 'vue', &#125;&#125;; 编写插件写 vue 插件稍微复杂一点 😢，根据官网的案例，我们需要提供一个包含 install 方法的对象或者一个函数（传送门），供 Vue.use 调用注册你的插件 写法一 123456789101112131415161718192021222324252627282930313233343536import Component from './YanProgress.vue'; // 这个就是你平时写的 SFC 组件// 这里要导出一个包含 install 方法的对象let plugin = &#123; // 这里要导出一个 install 方法 install(Vue,options) &#123; // 这里写你的代码，你可以全局注册组件，也可以写全局指令，也可以扩展 Vue 的方法 // 1. 全局组件 Vue.component('yan-progress',Component); // 2. 全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 3. 全局指令 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; &#125;) // 4. 注入组件 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; &#125;) // 5. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125; &#125;&#125;;if (window &amp;&amp; window.Vue) &#123; // 如果是渐进式开发（script 引入简单粗暴的开发方式），需要自动注册你的插件 window.Vue.use(plugin);&#125;export default plugin; 写法二 1234567891011121314import Component from './YanProgress.vue'; // 这个就是你平时写的 SFC 组件// 或者这里也可以写成函数function plugin(Vue,options) &#123; // 这里写你的代码，你可以全局注册组件，也可以写全局指令，也可以扩展 Vue 的方法 Vue.component('yan-progress',Component); &#125;&#125;;if (window &amp;&amp; window.Vue) &#123; // 如果是渐进式开发（script 引入简单粗暴的开发方式），需要自动注册你的插件 window.Vue.use(plugin);&#125;export default plugin; 这样写的原因是，下面源码伺候😄 12345678910111213141516171819export function initUse (Vue: GlobalAPI) &#123; Vue.use = function (plugin: Function | Object) &#123; // 在这里哦，可以传对象，也可以传函数 const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) &gt; -1) &#123; // 避免重复注册插件 return this &#125; // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === 'function') &#123; // 如果是带有 install 方法的对象 plugin.install.apply(plugin, args) // 不改变插件的 this（这里的 this 还是指向插件对象本身） &#125; else if (typeof plugin === 'function') &#123; // 如果是函数 plugin.apply(null, args) // 不改变插件的 this（这里应该是指向window，在浏览器非严格模式下） &#125; installedPlugins.push(plugin) return this &#125;&#125; 开源贡献拥抱开源，这样才能让社区，乃至行业发展更有动力，哎，似曾相识的赶脚，😂 注：例如，你的 star 是对我最大的鼓励，是支持我继续开源的动力，😄 awesome-vue 社区 awesome-vue 其他社区，可以到 Github 探索 完结撒花🎉👏 再次欢迎大家一起和我搞 ji 由（Github）😊 项目地址 https://github.com/Yangfan2016/vue-yan-progress 博客原文 https://yangfan2016.github.io react-yan-progress https://github.com/Yangfan2016/react-yan-progress vue-yan-progress https://github.com/Yangfan2016/vue-yan-progress","tags":[]},{"title":"快速构建一个 react 插件","date":"2019-01-04T07:21:36.000Z","path":"2019/01/04/快速构建一个-react-插件/","text":"前言一般情况下，我们写 React 项目，用 create-react-app 脚手架开发比较方便，但是如果要写一个插件的话，用三方脚手架就显得有点臃肿了，我们可以自己配置一个符合我们开发的简单工具，本文教你如何一步一步开发一个React 插件 ，let’s start 😊 准备工作工欲善其事，必先利其器，我们来选型 Typescript 为了方便开发，我们选用 Typescript 作为开发语言，可以即时类型检查，顺便还能装逼（巨硬大法好）， 注：Typescript 可选的，你也可以选择 js 刀耕火种，不过最好还是用 Typescript 写吧，毕竟9102年了，骚年 😄 webpack + babel 这里先用我们熟悉的 webpack 作为打包工具（之后会尝试改成 rollup 作为打包工具） jest + travis + coveralls jest 作为我们代码测试的工具,这里选用 travis ，一个在线持续集成的工具（帮助你打包、构建、运行scripts命令、代码测试等）选用 coveralls 可以根据 travis 代码测试后生成的代码覆盖率生成 badge（Github 好多项目都有的） 目录结构下面我们来大体组织下目录结构12345678910111213141516react-yan-progress├── build // 打包目录│ └── YanProgress.min.js├── src // 源码│ ├── index.css│ └── index.tsx├── test // 测试文件│ └── YanProgress.test.js├── index.d.ts // 声明文件（ts）├── jest.config.js // jest 测试配置文件├── webpack.config.js // webpack 配置文件├── tsconfig.json // ts 配置文件├── package.json├── .travis.yml // travis 配置文件├── LICENSE └── README.md 开发者选项所有的依赖的包如下 123456789101112131415161718192021&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/preset-react\": \"^7.0.0\", // for react \"@types/react\": \"^16.7.18\", // 声明文件 \"@types/react-dom\": \"^16.0.11\", // 声明文件 \"babel-loader\": \"^8.0.4\", \"chai\": \"^4.2.0\", // 测试断言库 \"coveralls\": \"^3.0.2\", // 代码覆盖率 \"css-loader\": \"^1.0.1\", \"jest\": \"^23.6.0\", // 测试工具 \"react\": \"^16.7.0\", \"react-dom\": \"^16.7.0\", \"style-loader\": \"^0.23.1\", \"ts-loader\": \"^5.3.2\", // 解析 ts \"typescript\": \"^3.2.2\", // 解析 ts \"webpack\": \"^4.25.1\", \"webpack-cli\": \"^3.1.2\" &#125; &#125; 命令配置如下，详情 package.json1234567&#123; \"scripts\": &#123; \"build\": \"webpack --config webpack.config.js --progress --colors\", \"test\": \"jest ./test/YanProgress.test.js\", \"coveralls\": \"cat ./coverage/lcov.info | coveralls\" &#125;,&#125; webpack 配置我们采用 webpack4 ,具体配置请看官网，传送门123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');module.exports = &#123; mode: \"production\", // 生产模式 entry: &#123; // 入口 \"YanProgress\": path.resolve(__dirname, './src/index.tsx') &#125;, output: &#123; // 出口 path: path.resolve(__dirname, './build'), filename: '[name].min.js', publicPath: \"./build/\", libraryTarget: 'commonjs2', // 注意这里按 commonjs2 模块规范打包 &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env', \"@babel/preset-react\"] &#125; &#125;, &#123; loader: 'ts-loader', // 解析 ts &#125; ], include: path.resolve(__dirname, \"./src/\"), // 只解析 src 目录下的文件 &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader?modules&amp;localIdentName=[hash:8]\", // css_modules 配置详情 http://www.ruanyifeng.com/blog/2016/06/css_modules.html include: path.resolve(__dirname, \"./src/\"), &#125; ] &#125;, resolve: &#123; // 省略文件后缀时，默认按下面的配置取 extensions: ['.ts', '.tsx', '.js'], &#125;, externals: &#123; // 不把 react 打包进去 react: 'react' &#125;&#125;; 【选读】Typescript 配置由于我们要在 ts 文件中 引入 css 模块，但是 ts 不认识，所以我们需要进行如下配置 在项目的根目录下新建一个 index.d.ts ts 声明文件 1declare module '*.css'; 开始编写插件这里就是与平常的开发组件一样，举个例子 1234567891011121314// jsximport React from 'react';class YanProgress extends React.Component&#123; render() &#123; return ( &lt;div&gt; 骚年，写代码快乐吗，看我干嘛 😄，赶快滚去写代码啊，别忘了点个 star 😂 &lt;/div&gt; ); &#125;&#125;export default YanProgress; // 记得导出啊，骚年 你可以直接看我写好的代码（然后 ctrl+c,ctrl+v），源码在这里，点我 安装依赖及代码压缩打包webpack4 默认会压缩代码，so 我们直接执行刚才 package.json 配置好的 scripts 的命令 12$ yarn$ yarn run build 代码测试 单元测试 可以在 test 目录下新建一个 xxx.test.js 的测试文件，写好测试用例（这里使用的是 chai 断言库的 expect 风格），执行如下命令 1$ yarn run test 包测试 如果你也想以 npm 包的形式引入（import YanProgress from &#39;react-yan-progress&#39;），测试的话，可以执行如下命令 在你的项目根目录下，打开终端运行如下命令，建立链接 1$ yarn link 在你要测试的 demo 项目根目录下，执行如下，然后你就可以这样使用了 import YanProgress from &#39;react-yan-progress&#39; 1$ yarn link react-yan-progress 持续集成这里用到比较方便简单的 travis 在线测试工具，和测试代码覆盖率工具 coveralls，网址如下：持续集成 https://travis-ci.org代码覆盖率 https://coveralls.io 注册使用过程就略过了，毕竟已经有很多教程了（面向谷歌编程 😂） 在项目根目录下新建一个 .travis.yml 文件，配置如下 1234567891011121314language: node_js # 运行环境node_js: - \"10.6.0\" # 版本branches: only: - master # 只有主支可以before_install: - export TZ='Asia/Shanghai' # 如果你的项目里涉及到时间处理，这里需要设置时区install: yarn install # 安装 npm 包script: # 执行命令 - yarn run build # 打包 - yarn run test # 测试after_success: # 成功之后执行如下命令 - yarn run coveralls # 测试代码覆盖率 发布 npm 包注册 npm 账号，注册过程略 注意之前，先去 npm 官网找一下，你的包名有木有被抢先占用了 执行如下命令进行发布1$ npm publish 升级包执行如下命令（x.x.x -&gt; major.minor.patch）1$ npm version patch 开源贡献拥抱开源，这样才能让社区，乃至行业发展更有动力 注：例如，你的 star 是对我最大的鼓励，是支持我继续开源的动力 React-componets 社区 awesome-react-components 其他社区，可以到 Github 探索 完结撒花🎉👏 欢迎大家一起和我搞 ji（Github）😊 项目地址 https://github.com/Yangfan2016/react-yan-progress#react-yan-progress 博客原文 https://yangfan2016.github.io","tags":[]},{"title":"You don't know cross-origin","date":"2018-11-19T12:19:05.000Z","path":"2018/11/19/You-don't-know-cross-origin/","text":"cross-origin Why 为什么会存在跨域问题 同源策略由于出于安全考虑，浏览器规定JavaScript不能操作其他域下的页面DOM，不能接受其他域下的xhr请求（不只是js，引用非同域下的字体文件，还有canvas引用非同域下的图片，也被同源策略所约束）只要协议、域名、端口有一者不同，就被视为非同域。 How 如何解决 要解决跨域问题，就要绕过浏览器对js的限制，另辟蹊径 JSONP这是最简单，也是最流行的跨域解决方案，它利用script标签不受同源策略的影响，解决跨域，需要后台配合，返回特殊格式的数据 前端12345678910111213&lt;script&gt; function JSONP(link) &#123; let script=document.createElement(\"script\"); script.src=link; document.body.appendChild(script); &#125; function getUser(data) &#123; console.log(data);// todo &#125; const API_URL_USER='http://cache.video.iqiyi.com/jp/avlist/202861101/1/?callback=getUser'; // 这里以爱奇艺的接口为例（来源网络，侵删） JSONP(API_URL_USER);&lt;/script&gt; 后端123456789101112131415161718// Express(Nodejs)// mock dataconst USERS=[ &#123;name:\"Tom\",age:23&#125;, &#123;name:\"Jack\",age:23&#125;];app.get(\"/user\",function (req,res) &#123; let cbName=req.query[\"callback\"]; // 这里做一个容错处理 res.send(` try&#123; $&#123;cbName&#125;($&#123;JSON.stringify(USRES)&#125;); &#125;catch(ex) &#123; console.error(\"The data is invalid\"); &#125; `);&#125;); CORS (cross-origin resource sharing)跨域资源共享，是W3C的一个标准，它允许浏览器发送跨域服务器的请求，CORS需要浏览器和服务器同时支持 后端 简单请求和非简单请求详情，请阅读阮一峰老师的博文，这里不再敖述1234567app.use(function (req,res,next)&#123; res.header('Access-Control-Allow-Origin', 'http://localhost:6666'); // 允许跨域的白名单，一般不建议使用 * 号 res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); // 允许请求的方法，非简单请求，会进行预检 res.header('Access-Control-Allow-Headers', 'Content-Type'); // 允许请求携带的头信息，非简单请求，会进行预检 res.header('Access-Control-Allow-Credentials','true'); // 允许发送cookie，这里前端xhr也需要一起配置 `xhr.withCredentials=true` next();&#125;); 代理只要是在与你同域下的服务器，新建一个代理（服务端不存在同源策略），将你的跨域请求全部代理转发 后端12const proxy=require(\"http-proxy-middleware\"); // 这里使用这个中间件完成代理app.use('/api', proxy(\"http://b.com\")); // http://a.com/api -&gt; http://b.com/api window.name+iframeMDN里解释道它是获取/设置窗口的名称，因为的它在不同页面甚至域名加载后值都不会改变，该属性也被用于作为 JSONP 的一个更安全的备选来提供跨域通信（cross-domain messaging） 前端123456789101112131415161718192021&lt;!--http://a.com/page1.html--&gt;&lt;script&gt; function request(url,callback) &#123; let iframe=document.createElement(\"iframe\"); let isFirst=true; iframe.style.display=\"none\"; iframe.addEventListener(\"load\",function () &#123; if (isFirst) &#123; isFirst=false; // 防止iframe循环加载 iframe.src=\"http://a.com/page2.html\"; callback &amp;&amp; callback(iframe.contentWindow.name); iframe.remove(); &#125; &#125;); iframe.src=url; &#125; requeset(\"http://b.com/user\",function (data) &#123; console.log(data); // todo &#125;);&lt;/script&gt; 后端1234567891011121314// Express(Nodejs)// mock dataconst USERS=[ &#123;name:\"Tom\",age:23&#125;, &#123;name:\"Jack\",age:23&#125;];app.get(\"/user\",function (req,res) &#123; res.send(` &lt;script&gt; ;window.name=$&#123;JSON.stringify(USERS)&#125;; &lt;/script&gt; `);&#125;); document.domian这个使用情况有限，例如http://a.c.comhttp://b.c.com主域相同时，分别设置他们页面的document.domain=&quot;c.com&quot;; locaction.hash+iframe嵌套两层iframe，达到第一层与第三层同域，就可以互相通信了 12345678910&lt;!--http://a.com/page1.html--&gt;&lt;script&gt; let iframe=document.createElement(\"iframe\"); iframe.style.display=\"none\"; iframe.src=\"http://b.com/user.html\"; window.addEventListener(\"hashchange\",function () &#123; console.log(location.hash.slice(1)); // todo &#125;);&lt;/script&gt; 12345678910111213141516171819&lt;!--http://b.com/user.html--&gt;&lt;script&gt; let iframe=document.createElement(\"iframe\"); iframe.style.display=\"none\"; function getUserData() &#123; fetch(\"http://b.com/user\") .then(res=&gt;&#123; let data=res.json(); iframe.src=`http://a.com/page2.html#$&#123;data&#125;`; &#125;); &#125; getUserData(); window.addEventListener(\"hashchange\",function () &#123; getUserData(); &#125;);&lt;/script&gt; 123&lt;script&gt; top.location.hash=window.location.hash;&lt;/script&gt; 图片ping这个只能发出去请求，无法获取到服务器的响应，常常用于网站流量统计 12345let img=new Image();img.addEventListener(\"load\",function () &#123; console.log(\"Send success\"); // todo&#125;);img.src=\"http://site.c.com/a.gif?count=666\"; postMessage+iframe 123456789101112131415161718&lt;!-- http://a.com --&gt;&lt;button id=\"sendBtn\"&gt;从B接口获取用户数据&lt;/button&gt;&lt;iframe src=\"http://b.com\" id=\"ifr\"&gt;&lt;/iframe&gt;&lt;script&gt;window.addEventListener(\"message\",function(&#123;detail,origin&#125;)&#123; if (origin===\"http://b.com\") &#123; // 最好判断下消息来源 if (detail.type===\"set-user\") &#123; console.log(detail.data); // todo &#125; &#125;&#125;);sendBtn.addEventListener(\"click\",function () &#123; ifr.contentWindow.postMessage(&#123; type:\"get-user\", &#125;,\"http://b.com\");&#125;);&lt;/script&gt; 123456789101112131415161718&lt;!-- http://b.com --&gt;&lt;script&gt;window.addEventListener(\"messagae\",function(&#123;detail,origin&#125;)&#123; if (origin===\"http://a.com\") &#123; // 最好判断下消息来源 if (detail.type===\"get-user\") &#123; fetch(\"http://b.com/user\") .then(res=&gt;&#123; top.contentWindow.postMessage(&#123; type:\"set-user\", data:res.json(), // 假设接口返回的是json格式的数据 &#125;,\"http://a.com\"); &#125;) &#125; &#125;&#125;);&lt;/script&gt; postMessage+form+iframe 这个需要后台配合返回特殊格式的数据，TL,DR 可以看这个demo WebSocket WebSocket是一种通信协议，该协议不实行同源政策，注意需要浏览器和服务器都支持的情况下 1234567 &lt;script src=\"//cdn.bootcss.com/socket.io/1.7.2/socket.io.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var io = io.connect('http://b.com'); io.on('data', function (data) &#123; console.log(data); // 接受来自服务器的消息 &#125;);&lt;/script&gt; 后端1234567// Nodejsconst server = require('http').createServer();const io = require('socket.io')(server);io.on('connection', function (client) &#123; client.emit('data', 'This message from \"http://b.com\"');&#125;); Summary 目前个人在工作中遇到的解决方法就是这些，当然还有许多其他的方法，你看，其实跨域并不难吧 ^_^ js通过xhr发的跨域请求，虽然得不到响应，但是可以发送出去，其实如果是单向通信的话，也可以，比如文章阅读统计，网站流量统计 Reference跨域资源共享 CORS 详解—阮一峰不要再问我跨域的问题了FatDong1/cross-domain","tags":[]},{"title":"Canvas 实现一个简单的贪吃蛇","date":"2018-11-15T05:46:49.000Z","path":"2018/11/15/Canvas-实现一个简单的贪吃蛇/","text":"Intro点击预览在之前的代码风格，和样式上做了大调整，如下图，主要是美化了移动端 Before before-pc After poster snake-game-pc Start移动端：中间的圆点按钮是重新开始，周围的方向按钮和游戏手柄操作一样web端：键盘方向键控制 Technology stackTypescriptrollupyarncanvas API Done 本次得分 历史最高分 移动端、web端适配 Todo 蛇的样式美化 游戏设置障碍物 Review and issuesgithub源码关注我","tags":[]},{"title":"一个简单前端工具集-yanjs","date":"2018-10-14T06:59:18.000Z","path":"2018/10/14/一个简单前端工具集/","text":"一个简单前端工具集-yanjs This is just a common toolkit for the Front End 安装使用 Install 1$ npm install yanjs Example 1var yanjs = require('yanjs'); Documentation使用文档 造轮子的初衷现在的前端发展正是百花齐放的时代，各种框架、各种库、各种插件层出不穷，为何还要重复造轮子内（毕竟大家都知道DRY，Don’t repeat yourself）： 为了公司内部使用，减少三方插件的依赖 为了轻量级，加快页面的加载速度，现有业务用目前流行的工具库（如 lodash.js）使用率不是很高，并不是所有功能都用上 现在业务的技术栈主要是Vue，要进一步去除jQuery的依赖，做一个替代jQuery里部分工具函数的过渡 为了熟悉实践下前端开发的流程，学习一下如何造轮子（向轮子哥vczh致敬），提升一下自己的水平 为大前端的发展添砖加瓦，^_^ 开发流程 开发需求主要是根据平时业务中常用的总结如下需求 ajax模块 时间格式转换模块 字符串格式转换模块 cookie模块 url解析模块 浏览器模块 开发依赖鉴于开发中常用的ajax库是axios，所以就不再重复造轮子了，简单的封装了下，cookie直接使用的是MDN封装好的docCookies axios docCookies 开发环境语言：Typescript 3.x转换：babel 7.x打包：webpack 4.x测试：mocha+chai+phantomjs 发布环境集成：Travis-ci发布：npm托管：github 开发心得 经历了第一次用typescript编写业务代码第一次发布npm包第一次用mocha测试工具完成代码测试第一次用Travis-ci集成工具 结果完整的体验了一次前端工程化开发，基本熟悉了整个开发流程公司内部已有两个项目在使用此库，已经基本稳定 碎碎念鄙人还在成长中，可能还有许多地方考虑不周，欢迎交流学习，欢迎提 issue 联系我：Github：https://github.com/Yangfan2016Blog： https://yangfan2016.github.io/Segmentfault：https://segmentfault.com/u/yangfan2016 大佬，点了star再走呗，^_^","tags":[]},{"title":"浅析js中的位运算及应用","date":"2018-09-23T12:47:47.000Z","path":"2018/09/23/浅析js中的位运算及应用/","text":"浅析js中的位运算及应用Example12345678910111213141516171819// 关于2的倍数的乘法除法4&gt;&gt;1 // 4/Math.pow(2,1) === 22&lt;&lt;2 // 2*Math.pow(2,2) === 8// 取整3.14|0 // 33.14^0 // 33.14&amp;3 // 3~~3.14 // 33.14&gt;&gt;0 // Math.floor(3/Math.pow(2,0)) === 33.14&lt;&lt;0 // Math.floor(3*Math.pow(2,0)) === 3// 不借助第三个变量下交换两数let a=1, b=2;a^=b;b^=a;a^=b;// a === 2,b === 1 Concept位运算符| 或 只要有一个为1，就为1&amp; 与 只有都是1的情况，才为1^ 异或 相同为0，不同为1~ 否 取反&lt;&lt; 左移 向左移动指定位数，尾部补0&gt;&gt; 右移 向右移动指定位数，首部补0&gt;&gt;&gt; 带符号右移 ConvertDemical 规则 逢十进一基数 10数码 0-9位权 10^n-1 举例 12// 转10进制100D === 1*10^2+0*10^1+0*10^0 Binary 规则 逢二进一基数 2数码 0-1位权 2^n-1 举例 12// 转10进制100B === 1*2^2+0*2^1+0*2^0 Octal 规则 逢八进一基数 8数码 0-7位权 8^n-1 举例 12// 转10进制100O === 1*8^2+0*8^1+0*8^0 Hex 规则 逢十六进一基数 16数码 0-9,a-f位权 16^n-1 举例 12// 转10进制100H === 1*16^2+0*16^1+0*16^0 Decaimal convert to others 短除法 短除法 1236D -&gt; 110B9D -&gt; 11O17D -&gt; 11H","tags":[]},{"title":"Javascript 继承","date":"2018-09-06T09:19:54.000Z","path":"2018/09/06/Javascript-类与继承/","text":"继承构造函数继承123456789101112131415function Parent() &#123; this.name='parent';&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; Parent.call(this);&#125;let c=new Child();c.name; // 'parent'c.run(); // undefined 缺点 无法继承父类原型上的方法 原型链实现继承1234567891011121314151617181920212223242526function Parent() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"];&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; &#125;Child.prototype=new Parent();Child.prototype.constructor=Child; var c1=new Child();var c2=new Child();c1.colors; // ['red','yellow']c2.colors; // ['red','yellow']c1.colors.push('green');c1.colors; // ['red','yellow','green']c2.colors; // ['red','yellow','green'] 缺点 子类共用一个父类的实例，造成数据污染 创建子类实例时，无法向父类构造函数传参 组合式继承123456789101112131415161718192021222324252627function Parent() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"]; console.log(\"I've executed\");&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; Parent.call(this);&#125;Child.prototype=new Parent();Child.prototype.constructor=Child;var c1=new Child(); // \"I've executed\" \"I've executed\"var c2=new Child(); // \"I've executed\" \"I've executed\"c1.colors; // ['red,yellow']c2.colors; // ['red,yellow']c1.colors.push('green');c1.colors; // ['red,yellow','green']c2.colors; // ['red,yellow'] 缺点 每新建一个子类都会调用两次父类构造器 寄生组合式继承123456789101112131415161718function Parent() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"];&#125;Parent.prototype.run=function () &#123; console.log('We can run');&#125;function Child() &#123; Parent.call(this);&#125;function Super() &#123;/* noop */&#125;Super.prototype=Parent.prototype;Child.prototype=new Super();Child.prototype.constructor=Child; 特点 完美实现继承 利用寄生函数实现父类构造函数只执行一次，将原型上的方法挂载到寄生函数上，最后将寄生函数的实例作为子类的原型对象 ES6 继承1234567891011121314151617class Parent &#123; constructor() &#123; this.name='parent'; this.colors=[\"red\",\"yellow\"]; &#125; run() &#123; console.log('We can run'); &#125;&#125;class Child extends Parent&#123; constructor() &#123; super(); this.name='child'; &#125;&#125; 特点 简单明了 只是一种语法糖而已 下面是babel将ES6转成ES5继承的实现 Babel 编译后的ES5代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889\"use strict\";// 创建类var _createClass = function() &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\"in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function(Constructor, protoProps, staticProps) &#123; // 定义原型对象的属性、方法 if (protoProps) defineProperties(Constructor.prototype, protoProps); // 定义类的静态属性、方法 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125; ;&#125;();// 确保子类初始化时调用superfunction _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); &#125; return call &amp;&amp; (typeof call === \"object\" || typeof call === \"function\") ? call : self;&#125;// 继承function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); &#125; // 利用 Object.crete 创建了一个父类原型对象的新实例，并且修正了构造器指向 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); // 将子类原型链链到父类上 if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;// 安全检测，确保用 'new' 操作的构造函数function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Parent = function() &#123; function Parent() &#123; _classCallCheck(this, Parent); this.name = 'parent'; this.colors = [\"red\", \"yellow\"]; &#125; _createClass(Parent, [&#123; key: \"run\", value: function run() &#123; console.log('We can run'); &#125; &#125;]); return Parent;&#125;();var Child = function(_Parent) &#123; _inherits(Child, _Parent); function Child() &#123; _classCallCheck(this, Child); var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this)); _this.name = 'child'; return _this; &#125; return Child;&#125;(Parent);","tags":[]},{"title":"十大经典排序算法-JavaScript篇","date":"2018-08-13T07:28:20.000Z","path":"2018/08/13/十大经典排序算法-JavaScript篇/","text":"备注 语法为 ES6 以下排序默认按升序排序 测试案例均为自然数 前言排序作为十分经典的算法之一。是每一个软件工程师的必备技能，学好排序算法，可以提高软件的运行效率，最重要的是掌握其算法设计思想，才能举一反三应用到实际的实践中，为己所用。 排序算法简介 按照数据的大小，排序算法可以分为内部排序和外部排序（数据较大，需要借助外存） 内部排序，又可以细分为 交换排序、插入排序、选择排序 1. 冒泡排序简介：两两元素进行比较，较大者放置后头，类似水中的气泡较大者浮在水的上端性能平均时间复杂度 O(n^2) 代码：12345678910111213141516function bubble(arr) &#123; let len = arr.length, i = 0, j = 0; // 循环 n-1 趟 for (i = 0; i &lt; len; i++) &#123; // 每趟 需比较 n-i-1 次 for (j = 0; j &lt; len - 1 - i; j++) &#123; // 如果后面的元素较大，则交换两者顺序 if (arr[j + 1] &lt; arr[j]) &#123; arr[j] = [arr[j + 1], arr[j + 1] = arr[j]][0]; &#125; &#125; &#125; return arr;&#125; 2. 快速排序简介：取一个元素为基准，把序列分成两部分，小于基准的放到它的左面，大于等于的放到它的右面，然后在把左面和右面的子序列再进行上述的拆分，直到子序列不可再分割（小于2个元素），最终达到整个序列有序性能平均时间复杂度 O(n*logn) 代码1234567891011121314151617181920function quick(arr) &#123; // 不可再分割，直接退出 if (arr.length &lt;= 1) return arr; let len = arr.length, middle = len &gt;&gt; 1, pivot = (len--) &amp;&amp; arr.splice(middle, 1)[0], // 取中间为基准数，并从数组中移除 left = [], right = [], i = 0; for (i = 0; i &lt; len; i++) &#123; // 分组 小于基准的放到左边，反之 if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return [...quick(left), pivot, ...quick(right)]; // 合并&#125; 3. 简单选择排序简介：假设一个有序序列，然后由剩余的元素中选出最小的（最大的）扔到有序序列，直到无序序列元素为空，从而达到整个序列有序性能平均时间复杂度 O(n^2) 代码12345678910111213141516171819function selection(arr) &#123; let len = arr.length, i = 0, j = 0, min = i; // 循环 n-1 趟 for (i = 0; i &lt; len - 1; i++) &#123; min = i; // 假设每趟的第一个数为最小值 for (j = i + 1; j &lt; len; j++) &#123; // 如果后面的树大于最小数（min对应的数），则重新对最小值的索引赋值 if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; // 将最小数置于该趟排序的第一个位置 arr[i] = [arr[min], arr[min] = arr[i]][0]; &#125; return arr;&#125; 4. 堆排序简介：是简单选择排序的改进版，利用堆结构性能平均时间复杂度 O(n*logn) 代码12345678910111213141516171819202122232425262728293031323334// 堆排序function heapSort(arr) &#123; var n = arr.length, i, j; // 筛选 var sift = (k, m, r) =&gt; &#123; var p = k, // 父结点 c = p * 2 + 1; // 左结点（默认最大） while (c &lt;= m) &#123; // 左结点(c=m)和左右结点(c&lt;m) if (c &lt; m &amp;&amp; r[c + 1] &gt; r[c]) c++; // 选出左右结点中的最大者，指向左结点 if (r[p] &gt; r[c]) break; // 父结点大于左结点 顺序正确，退出循环 else &#123; r[p] = [r[c], r[c] = r[p]][0]; // 将大的一方置于顶部（父结点） p = c; // 向下重新指向父结点 c = p * 2 + 1; // 向下重新指向左结点 &#125; &#125; &#125;; // 构建堆 for (i = (n / 2 | 0) - 1; i &gt;= 0; i--) &#123; // 从最后一个分支结点开始向上逆序遍历 sift(i, n - 1, arr); &#125; // 排序 for (j = n - 1; j &gt;= 0; j--) &#123; arr[0] = [arr[j], arr[j] = arr[0]][0]; // 将最大的结点存于数组的最后一位 n--; // 减少数组长度，排除有序序列 sift(0, n - 1, arr, true); &#125; return arr;&#125; 5. 直接插入排序简介：假设数组的一有序序列，从后面的无序序列中，扫描，与有序序列比较，插入到合适位置性能平均时间复杂度 O(n^2) 代码12345678910111213141516171819function insertion(arr) &#123; let len = arr.length, i = 0, j = 0, temp; // [7,6,2,5,4,3,1] // 从第二个元素开始循环 for (i = 1; i &lt; len; i++) &#123; temp = arr[i]; // 存储当前元素 j = i - 1; // 待插入队列的序号 while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; // 当没有出界 且 当前元素比待插序列元素小时，进行待插序列的元素向后移动一位 arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = temp; // 将当前元素插入到待插序列的下一位 &#125; return arr;&#125; 6. 希尔排序简介：一种改进版的插入排序，每次比较的是用增量分割的序列，达到部分有序，随着增量依次递减，序列逐渐达到完全有序性能平均时间复杂度 O(n*logn) 代码123456789101112131415161718192021222324function shell(arr) &#123; let len = arr.length, i = 0, j = 0, temp, gap = 1; gap = len / 3 | 0; // 计算增量 while (gap &gt;= 1) &#123; // 增量大于2时，进行简单插入排序 for (i = gap; i &lt; len; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap = gap / 3 | 0; // 增量减少 &#125; return arr;&#125; 7. 归并排序简介：利用分治法，将序列分为许多小子序列，然后每个子序列进行排序，然后逐次合并，最后达到整体有序，这里用的是二路归并排序（归并排序中最简单的一种）性能平均时间复杂度 O(n*logn) 代码123456789101112131415161718192021222324252627282930function merge(arr) &#123; return (&#123; sortArr(leftArr, rightArr) &#123; // 排序 let res = []; // 合并 while (leftArr.length * rightArr.length !== 0) &#123; if (leftArr[0] &lt; rightArr[0]) &#123; res.push(leftArr.shift()); &#125; else &#123; res.push(rightArr.shift()); &#125; &#125; leftArr.length &gt; 0 &amp;&amp; (res = [...res, ...leftArr]); rightArr.length &gt; 0 &amp;&amp; (res = [...res, ...rightArr]); return res; &#125;, mergeArr(brr) &#123; // 合并 if (brr.length &lt;= 1) return brr; let len = brr.length, left = [], right = [], middle; middle = len &gt;&gt; 1; // 分组 left = brr.slice(0, middle); right = brr.slice(middle); return this.sortArr(this.mergeArr(left), this.mergeArr(right)); &#125; &#125;).mergeArr(arr)&#125; 8. 计数排序简介：利用分配概念，将元素一一映射到桶中，每个桶只存储单一值性能平均时间复杂度 O(n+m) 代码1234567891011121314151617181920212223242526function countingSort(arr) &#123; var max = Math.max(...arr), min = Math.min(...arr), len = arr.length, i, bucket = [], result = []; // 入桶 for (i = 0; i &lt; len; i++) &#123; var item = arr[i]; bucket[item] = bucket[item] || 0; // 建立映射表 bucket[item]++; // 相同元素对应到同一映射表中，映射表增加1 &#125; // 出桶 for (i = min; i &lt;= max; i++) &#123; var count = bucket[i]; // 取每个映射表的元素数量 while (count &gt; 0) &#123; // 如果数量大于0 ，重复输出该元素 result.push(i); count--; &#125; &#125; return result;&#125; 9. 桶排序简介：利用分配概念，每个桶存储一定范围的数值，然后桶内在进行排序，最后所有桶的元素出桶达到完全有序性能平均时间复杂度 O(n+m) 代码123456789101112131415161718192021222324252627282930313233343536function bucketSort(arr, num) &#123; var len = arr.length, max = Math.max(...arr), min = Math.min(...arr), result = [], bucket = [], space, i; // 至少2个桶 num = num &gt; 2 ? num : 2; // 计算每个桶的容量 space = ((max - min) / num | 0) + 1; // 入桶 for (i = 0; i &lt; len; i++) &#123; var item = arr[i]; var index = (item - min) / space | 0; // 计算元素入桶的位置，要放入哪个桶 bucket[index] = bucket[index] || []; bucket[index].push(item); if (bucket[index].length &gt; 1) &#123; // 桶里的元素再进行排序（这里使用的是简单插入排序） bucket[index] = insertion(bucket[index]); &#125; &#125; // 出桶 for (i = 0; i &lt; num; i++) &#123; var list = bucket[i] || []; if (list.length &gt; 0) &#123; result = result.concat(list); &#125; &#125; return result;&#125; 10. 基数排序简介：利用分配概念，根据元素的基数来分配桶 最低位优先法，简称LSD法：先从最低位开始排序，再对次低位排序，直到对最高位排序后得到一个有序序列 最高位优先法，简称MSD法：先从最高位开始排序，再逐个对各分组按次高位进行子排序，循环直到最低位 性能平均时间复杂度 O(n*m) 代码1234567891011121314151617181920212223242526272829303132function radixSort(arr) &#123; var len = arr.length, max = Math.max(...arr), bucket = [], result = [], i, j, k, hight = String(max).length; // 计算最大数的位数 for (i = 1; i &lt;= hight; i++) &#123; // 其实就是循环hight次的计数排序 result = []; bucket = []; // 入桶 for (j = 0; j &lt; len; j++) &#123; var item = arr[j] + \"\"; // 这里转换为string 类型，方便取具体位数的值，当然mod10也可以 var index = item.length - i &lt; 0 ? 0 : item.substr(item.length - i, 1); // 取第(item.len-i+1)位的数 bucket[index] = bucket[index] || []; // 这里就和计数排序一样了 bucket[index].push(+item); &#125; // 出桶 for (k = 0; k &lt; bucket.length; k++) &#123; if (bucket[k] &amp;&amp; bucket[k].length &gt; 0) &#123; result = result.concat(bucket[k]); &#125; &#125; arr = result; &#125; return result;&#125; 性能比较 sort 参考 《十大经典排序算法》","tags":[{"name":"算法","slug":"算法","permalink":"http://yangfan.site/tags/算法/"}]},{"title":"微信扫码登录原理解析","date":"2018-07-03T10:16:26.000Z","path":"2018/07/03/微信扫码登录原理解析/","text":"微信扫码登录原理解析 扫码登录是现在流行的登录方式，使用这种方式及其方便，而且安全 扫码登录流程 look.jpg 原理 获取唯一的uuid, 以及包含uid信息的二维码 12345678910111213141516171819202122232425262728293031323334353637383940414243 // 获取uuid getUUID: function() &#123; var e = t.defer(); return window.QRLogin = &#123;&#125;, $.ajax(&#123; url: i.API_jsLogin, dataType: \"script\" &#125;).done(function() &#123; 200 == window.QRLogin.code ? e.resolve(window.QRLogin.uuid) : e.reject(window.QRLogin.code) &#125;).fail(function() &#123; e.reject() &#125;), e.promise &#125;``` 2. 浏览器轮询服务器，获取扫码状态 ```js// 查看扫码状态checkLogin: function(e, a) &#123; var n = t.defer() , a = a || 0; return window.code = 0, window.checkLoginPromise = $.ajax(&#123; url: i.API_login + \"?loginicon=true&amp;uuid=\" + e + \"&amp;tip=\" + a + \"&amp;r=\" + ~new Date, dataType: \"script\", timeout: 35e3 &#125;).done(function() &#123; new RegExp(\"/\" + location.host + \"/\"); if (window.redirect_uri &amp;&amp; window.redirect_uri.indexOf(\"/\" + location.host + \"/\") &lt; 0) return void (location.href = window.redirect_uri); var e = &#123; code: window.code, redirect_uri: window.redirect_uri, userAvatar: window.userAvatar &#125;; n.resolve(e) &#125;).fail(function() &#123; n.reject() &#125;), n.promise&#125; 根据服务器返回的扫码状态，进行相应的操作 408 扫码超时 如果手机没有扫码或没有授权登录，服务器会阻塞约25s，然后返回状态码 408 -&gt; 前端继续轮询 400 二维码失效 大约5分钟的时间内不扫码，二维码失效 201 已扫码 如果手机已经扫码，服务器立即返回状态码和用户的基本信息 （window.code=201,window.code.userAvator=”…”），-&gt; 前端继续轮询 200 已授权 如果手机点击了确认登录，服务器返回200及token -&gt; 前端停止轮询, 获取到token，重定向到目标页 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 根据服务器返回的扫码状态，进行相应的操作function o(c) &#123; switch (c.code) &#123; case 200: t.newLoginPage(c.redirect_uri).then(function(t) &#123; var o = t.match(/&lt;ret&gt;(.*)&lt;\\/ret&gt;/) , r = t.match(/&lt;script&gt;(.*)&lt;\\/script&gt;/) , c = t.match(/&lt;skey&gt;(.*)&lt;\\/skey&gt;/) , s = t.match(/&lt;wxsid&gt;(.*)&lt;\\/wxsid&gt;/) , l = t.match(/&lt;wxuin&gt;(.*)&lt;\\/wxuin&gt;/) , d = t.match(/&lt;pass_ticket&gt;(.*)&lt;\\/pass_ticket&gt;/) , f = t.match(/&lt;message&gt;(.*)&lt;\\/message&gt;/) , u = t.match(/&lt;redirecturl&gt;(.*)&lt;\\/redirecturl&gt;/); return u ? void (window.location.href = u[1]) : o &amp;&amp; \"0\" != o[1] ? (alert(f &amp;&amp; f[1] || \"登陆失败\"), i.report(i.AUTH_FAIL_COUNT, 1), void location.reload()) : (e.$emit(\"newLoginPage\", &#123; Ret: o &amp;&amp; o[1], SKey: c &amp;&amp; c[1], Sid: s &amp;&amp; s[1], Uin: l &amp;&amp; l[1], Passticket: d &amp;&amp; d[1], Code: r &#125;), void (a.getCookie(\"webwx_data_ticket\") || n.report(n.ReportType.cookieError, &#123; text: \"webwx_data_ticket 票据丢失\", cookie: document.cookie &#125;))) &#125;); break; case 201: e.isScan = !0, n.report(n.ReportType.timing, &#123; timing: &#123; scan: Date.now() &#125; &#125;), t.checkLogin(e.uuid).then(o, function(t) &#123; !t &amp;&amp; window.checkLoginPromise &amp;&amp; (e.isBrokenNetwork = !0) &#125;); break; case 408: t.checkLogin(e.uuid).then(o, function(t) &#123; !t &amp;&amp; window.checkLoginPromise &amp;&amp; (e.isBrokenNetwork = !0) &#125;); break; case 400: case 500: case 0: var s = a.getCookie(\"refreshTimes\") || 0; s &lt; 5 ? (s++, a.setCookie(\"refreshTimes\", s, .5), document.location.reload()) : e.isNeedRefresh = !0; break; case 202: e.isScan = !1, e.isAssociationLogin = !1, a.setCookie(\"login_frequency\", 0, 2), window.checkLoginPromise &amp;&amp; (window.checkLoginPromise.abort(), window.checkLoginPromise = null ), r() &#125; e.code = c.code, e.userAvatar = c.userAvatar, a.log(\"get code\", c.code)&#125; 总结 轮询采用的是JSONP的形式，排除了跨域问题 轮询采用的后台根据扫码情况阻塞前台请求，优化轮询及减少前端的无效轮询","tags":[]},{"title":"Debounce and Throttle","date":"2018-06-22T08:41:29.000Z","path":"2018/06/22/Debounce-and-Throttle/","text":"防抖动与节流 DEMO 防抖动12345678910111213141516171819202122232425262728var debounce = function (fn, delay, isImmediate) &#123; var timer = null; // 默认不立即触发 isImmediate = typeof isImmediate === \"undefined\" ? false : isImmediate; return function () &#123; var ctx = this, // 保存作用域 args = arguments; // 保存参数 // 初始化清空所有定时器 if (timer) &#123; clearTimeout(timer); &#125; // 如果是立即触发 if (isImmediate) &#123; if (!timer) &#123; // timer为空时触发操作 fn.apply(ctx, args); &#125; // delay时间后置空timer timer = setTimeout(_ =&gt; &#123; timer = null; &#125;, delay); &#125; else &#123; // delay时间后触发操作 timer = setTimeout(_ =&gt; &#123; fn.apply(ctx, args); &#125;, delay); &#125; &#125;;&#125;; 防抖动立即触发 debounce-immediate.png 防抖动 debounce.png 节流123456789101112131415161718var throttle = function (fn, delay, isImmediate) &#123; var timer = null; // 默认立即触发 isImmediate = typeof isImmediate === \"undefined\" ? true : isImmediate; return function () &#123; var ctx = this, // 保存作用域 args = arguments; // 保存参数 if (!timer) &#123; // timer为空时 if (isImmediate) fn.apply(ctx, args); // 立即触发 timer = setTimeout(function () &#123; clearTimeout(timer); timer = null; if (!isImmediate) fn.apply(ctx, args); // delay时间后触发操作 &#125;, delay); &#125; &#125;;&#125;; 节流立即触发 throttle-immediate.png 节流 throttle.png 总结 防抖动：将多个操作合并为一个操作（例如，键盘输入关键字搜索内容），在规定延时时间后触发，如果在定时器时间范围内触发，则会清楚定时器，重新计时 节流：在给定的延时时间后触发一次操作，在此时间范围内的操作均不触发（例如，图片懒加载、向下无限滚动获取新数据）","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"网站优化","slug":"网站优化","permalink":"http://yangfan.site/tags/网站优化/"}]},{"title":"浏览器杂谈","date":"2018-06-05T02:56:31.000Z","path":"2018/06/05/浏览器杂谈/","text":"浏览器缓存（协议层的缓存） 主要分为强缓存和协商缓存，详情 https://segmentfault.com/a/1190000011212929 强缓存 浏览器会先获取该资源缓存的header信息，根据其中的Expires和Cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源 协商缓存 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 reflow(重排)和repaint(重绘) reflow &amp; repainthttps://www.jianshu.com/p/40c6fc1d4800http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html 浏览器解析网页的过程 HTML代码转化成DOM CSS代码转化成CSSOM（CSS Object Model） 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 重排与重绘 重排：渲染树的结点发生了结构性变化，例如宽度、高度或者位置上的变化时，那么会触发reflow(重排)的逻辑。第一次进入一个页面时便会至少触发一次重排。 重绘：渲染树结点发生了非结构性变化，例如背景色等的变化时，那么会触发repaint(重绘)。 AST（抽象语法树）定义抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上 应用抽象语法树的作用非常的多，比如编译器、IDE、压缩优化代码等。在JavaScript中，虽然我们并不会常常与AST直接打交道，但却也会经常的涉及到它。例如使用UglifyJS来压缩代码，实际这背后就是在对JavaScript的抽象语法树进行操作，例如 Babel编译ES6的代码","tags":[]},{"title":"浏览器兼容性问题Q&A","date":"2018-05-14T03:07:01.000Z","path":"2018/05/14/浏览器兼容性问题Q-A/","text":"浏览器兼容性问题Q&amp;ADate 对象时间格式差异性Q: 日期参数为 yyyy/MM/dd hh:mm:ss 格式时，IE浏览器不支持，chrome和firefox支持1new Date(\"2018-05-05 12:25:23\") // Invalid Date 日期参数为 yyyy/MM/ddThh:mm:ss 格式时，IE支持,chrome和firefox也支持 1new Date(\"2018-05-05T12:25:23\") // [date] Sat May 05 2018 12:25:23 GMT+0800 (中国标准时间) A:原因：各个浏览器对采用的时间格式标准解析不一致 解决方法：最好采用ISO的标准时间格式YYYY-MM-DDTHH:mm:ss.sssZ或者使用时间戳代替 123456new Date(\"2018-05-05T12:25:23.235Z\");// ornew Date(1525523123235) window.open 在异步代码中执行被浏览器拦截Q:下面方式打开新页面会被浏览器拦截1234567891011121314// 异步代码setTimeout(function () &#123; window.open(\"http://www.sogou.com\")&#125;,1001)// AJAX异步请求$.ajax(&#123; url:\"xxx\", success:function () &#123; window.open(\"yyy\") &#125;&#125;); A:原因：出于安全考虑浏览器会拦截掉非用户操作的行为 解决方法：12345678// window.open()先执行，打开一个空的窗口（例如 加载页）var newWin = window.open('http://xxx.com/loading.html')// 然后等异步代码执行完再重定向 newWin.location.href = 'http://www.baidu.com' a 标签href属性为javascript:void(0) 时，各浏览器处理方式不同Q:1&lt;a href=\"javascript:void(0)\" target=\"_blank\"&gt;我是空链接，在这里当做一个按钮&lt;/a&gt; firefox和IE浏览器会弹出一个新窗口 A:原因：浏览器默认处理事件的顺序有差异。Chrome顺序：onclick -&gt; href -&gt; targetIE和Firefox顺序：onclick -&gt; target -&gt; href 解决方法： 添加onclick事件，直接return false阻止之后浏览器默认事件的执行 1&lt;a target=\"_blank\" onclick=\"return false\" href=\"javascript:void(0);\"&gt;点我啊&lt;/a&gt; 去掉href属性 1&lt;a target=\"_blank\"&gt;点我啊&lt;/a&gt; 1&lt;a&gt;点我啊&lt;/a&gt; 各浏览器对 table 不规范写法解析不一致最好以W3C的标准来写HTML，不然浏览器对HTML解析有差异 1234567891011121314151617181920&lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 鼠标事件 mouseout 和 mouseleave 区别 mouseleave 只有鼠标移开被监听的元素时，才触发 （mouseenter同理） mouseout 不论鼠标移开被监听元素，还是子元素，均会触发（mouseover同理） window.URL.createObjectURL(new Blob) 在Microsoft IE和Chrome 的区别 https://blog.csdn.net/u013131203/article/details/80894440Chrome 带域名 123URL.createObjectURL(new Blob())// \"blob:https://note.youdao.com/e4132750-7b95-4595-b331-158267d8d9e3\" ie不带域名 123URL.createObjectURL(new Blob())// \"blob:e4132750-7b95-4595-b331-158267d8d9e3\" IE浏览器缓存 get方式的XHR请求 https://www.cnblogs.com/bk233/p/7280595.html每次发请求时携带一个随机参数 例如 GET http://123.com?t=15123153156161 浅谈 AJAX 跨域请求时的 OPTIONS 方法 https://juejin.im/entry/58eaf351a22b9d0058a8e35cFor cross-domain requests, setting the content type to anything other than application/x-www-form-urlencoded, multipart/form-data, or text/plain will trigger the browser to send a preflight OPTIONS request to the server.非简单请求必须先发送预检请求，如果发送的请求内容类型如果不是 application/x-www-form-urlencoded，multipart/form-data 或 text/plain 这三者的话，便会触发 OPTIONS 请求","tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yangfan.site/tags/浏览器/"},{"name":"兼容性","slug":"兼容性","permalink":"http://yangfan.site/tags/兼容性/"}]},{"title":"入门级的git使用指北","date":"2018-05-08T04:08:03.000Z","path":"2018/05/08/入门级的git使用指北/","text":"Git 一种免费的开源分布式版本控制系统 Config12345678910111213# 全局配置 加 --global 标识$ git config --global user.name \"your name\" $ git config --global user.email \"xxx@xxx.xxx\"# 本地配置$ git config user.name \"your name\"# 查看配置 --list,-l$ git config --list# 查看指定项$ git config user.name# 修改指定项$ git config core.eol lf # git config &lt;key&gt; &lt;value&gt;# 删除指定项$ git config --unset core.eol # git config --unset &lt;key&gt; Basic123456789101112131415161718192021222324# init$ git init # 创建一个空的Git仓库或重新初始化一个现有仓库# add remote origin$ git remote add origin https://github.com/username/xxxx.git # 添加一个远程仓库 git remote add &lt;shortname&gt; &lt;远程版本库&gt;$ git remote # 查看已经存在的远程分支$ git remote -v # 查看已经存在的远程分支的详细信息 git remote -v | --verbose# pull$ git pull https://github.com/username/xxxx.git master # 拉取数据$ git pull origin master # origin 为你之前添加一个远程仓库的名字# add$ git add readme.txt # 添加单个文件到本地暂存区$ git add . # 添加所有修改、新增的文件到本地暂存区$ git add -u # 添加所有修改、删除的文件到本地暂存区$ git add -A # 添加所有修改、删除、新增文件到本地暂存区# commitgit commit -m \"注释\" # 此次提交的备注# pushgit push -u origin master # 将本地的master分支同步到origin所在主机的master分支 Diff1$ git diff # 查看冲突 Branch1234567$ git branch # 查看所有分支（当前分支有星号标记 e.g. *master）$ git branch -a # 查看所有分支（包括远程分支）$ git branch dev # 创建分支$ git checkout dev # 切换到 dev 分支$ git checkout -b feature # 新建并切换到 feature 分支 $ git branch -m feature test # 重命名 git branch -m &lt;旧名字&gt; &lt;新名字&gt;$ git branch -D test # 删除分支 Merge12$ git checkout master # 切换到 mastet 分支$ git merge dev # 将 dev 合并到 当前分支（这里是 master） Clone123$ git clone http://xxx.xxx/xxx.git # git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;$ git clone http://xxx.xxx/xxx.git mydir # git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;$ git clone -b dev http://xxx.xxx/xxx.git #git clone -b &lt;分支名称&gt; &lt;版本库的网址&gt; View12$ git status # 查看当前工作区提交状态$ git log # 查看提交历史记录 Undogit add 之前1$ git checkout -- a.js # 撤销某个/某些文件的更改 git add 之后，git commit 之前1$ git reset HEAD a.js # 撤销某个/某些文件的添加 git commit 之后12$ git reset HEAD^ --hard # 撤销本次提交（commit）$ git reset &lt;commit_id&gt; --hard # 撤回到指定的 commit Editor &amp;&amp; Git Config123$ git config core.autocrlf false # 禁止自动转换换行符$ git config core.safecrlf true # 禁止换行符混用$ git config core.eol lf # 设置换行符为 LF Reset12$ git reset HEAD^$ git reset HEAD~2 Relationship git-relationship Refs git-scm Git教程","tags":[{"name":"博客","slug":"博客","permalink":"http://yangfan.site/tags/博客/"},{"name":"Git","slug":"Git","permalink":"http://yangfan.site/tags/Git/"}]},{"title":"Vue工程化开发（一）","date":"2018-01-12T02:58:42.000Z","path":"2018/01/12/Vue工程化开发（一）/","text":"Vue工程化开发（一） 利用Vue-cli脚手架在现有的MVC项目中进行前端开发 开发环境 Node npm Vue-cli 搭建项目1. 首先在项目中搭建一个前台文件夹，用 vue init webpack projectname （例如: vue init webpack frontend）frontend 为Vue-cli自动生成的项目文件content 目录下存放打包后的资源文件views目录下存放自动生成的cshtml文件 2. 进入此文件夹（这里是 frontend） 配置 package.json ，安装所需插件 3. 修改打包配置 进入 config/index.js 修改如下 4. 在当前目录下新建一个模板页 index.cshtml 如下 5. 修改打包html文件的配置 进入 build/webpack.prod.conf.js 6. npm run dev 测试7. npm run build 打包项目目录","tags":[]},{"title":"[转]如何监听DOM树改变","date":"2017-11-08T02:06:44.000Z","path":"2017/11/08/转-如何监听DOM树改变/","text":"如何监听DOM树改变[转]读前必看MutationObserver MDNhttps://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver Mutation Observer API http://javascript.ruanyifeng.com/dom/mutationobserver.html#toc10 1 概述Mutation observer 是用于代替 Mutation events 作为观察DOM树结构发生变化时，做出相应处理的API。为什么要使用mutation observer 去代替 mutation events 呢，我们先了解一下mutation events Mutation Events Mutation events 是在 DOM3中定义，用于监听DOM树结构变化的事件 它简单的用法如下：1234document.getElementById('list').addEventListener(\"DOMSubtreeModified\", function()&#123; console.log('列表中子元素被修改');&#125;, false); Mutation 事件列表DOMAttrModifiedDOMAttributeNameChangedDOMCharacterDataModifiedDOMElementNameChangedDOMNodeInsertedDOMNodeRemovedDOMNodeInsertedIntoDocumentDOMSubtreeModified 其中DOMNodeRemoved，DOMNodeInserted 和 DOMSubtreeModified 分别用于 监听元素子项的删除，新增，修改(包括删除和新增），DOMAttrModified 是监听元素属性的修改，并且能够提供具体的修改动作。 Mutation Events遇到的问题浏览器兼容性问题IE9不支持Mutation EventsWebkit内核不支持DOMAttrModified特性，DOMElementNameChanged和DOMAttributeNameChanged 在Firefox上不被支持。性能问题 Mutation Events是同步执行的，它的每次调用，都需要从事件队列中取出事件，执行，然后事件队列中移除，期间需要移动队列元素。如果事件触发的较为频繁的话，每一次都需要执行上面的这些步骤，那么浏览器会被拖慢。 Mutation Events本身是事件，所以捕获是采用的是事件冒泡的形式，如果冒泡捕获期间又触发了其他的MutationEvents的话，很有可能就会导致阻塞Javascript线程，甚至导致浏览器崩溃。 Mutation Observer Mutation Observer 是在DOM4中定义的，用于替代 mutation events 的新API，它的不同于events的是，所有监听操作以及相应处理都是在其他脚本执行完成之后异步执行的，并且是所以变动触发之后，将变得记录在数组中，统一进行回调的，也就是说，当你使用observer监听多个DOM变化时，并且这若干个DOM发生了变化，那么observer会将变化记录到变化数组中，等待一起都结束了，然后一次性的从变化数组中执行其对应的回调函数。 Mutation Observer 的浏览器兼容范围 兼容性2 方法构造函数用来实例化一个Mutation观察者对象，其中的参数是一个回调函数，它是会在指定的DOM节点发送变化后，执行的函数，并且会被传入两个参数，一个是变化记录数组(MutationRecord)，另一个是观察者对象本身 12new MutationObserver(function(records, itself)&#123;&#125;); observe 在观察者对象上，注册需要观察的DOM节点，以及相应的参数 12void observe(Node target, optional MutationObserverInit options) 其中的可选参数 MutationObserverInit的属性如下： childLIst 观察目标节点的子节点的新增和删除。attributes 观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化)。characterData 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化subtree 观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化)attributeOldValue 在attributes属性已经设为true的前提下, 将发生变化的属性节点之前的属性值记录下来(记录到下面MutationRecord对象的oldValue属性中)characterDataOldValue 在characterData属性已经设为true的前提下,将发生变化characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中)attributeFilter 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些删选参数的话，如果想要使用哪个参数的话，就将其值设定为true disconnect 暂定在观察者对象上设置的节点的变化监听，直到重新调用observe方法 takeRecords 在观察者对象上调用takeRecords 会返回 其观察节点上的变化记录(MutationRecord)数组其中MutationRecord数组也会作为，观察者初始化时的回调函数的第一个参数其包含的属性如下： type 如果是属性发生变化,则返回attributes.如果是一个CharacterData节点发生变化,则返回characterData,如果是目标节点的某个子节点发生了变化,则返回childList.target 返回此次变化影响到的节点,具体返回那种节点类型是根据type值的不同而不同的,如果type为attributes,则返回发生变化的属性节点所在的元素节点,如果type值为characterData,则返回发生变化的这个characterData节点.如果type为childList,则返回发生变化的子节点的父节点.addedNodes 返回被添加的节点removedNodes 返回被删除的节点previousSibling 返回被添加或被删除的节点的前一个兄弟节点nextSibling 返回被添加或被删除的节点的后一个兄弟节点attributeName 返回变更属性的本地名称oldValue 根据type值的不同,返回的值也会不同.如果type为attributes,则返回该属性变化之前的属性值.如果type为characterData,则返回该节点变化之前的文本数据.如果type为childList,则返回null 3 使用实例1234567891011121314151617// Firefox和Chrome早期版本中带有前缀var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver// 选择目标节点var target = document.querySelector('#some-id'); // 创建观察者对象var observer = new MutationObserver(function(mutations) &#123; mutations.forEach(function(mutation) &#123; console.log(mutation.type); &#125;); &#125;); // 配置观察选项:var config = &#123; attributes: true, childList: true, characterData: true &#125; // 传入目标节点和观察选项observer.observe(target, config); // 随后,你还可以停止观察observer.disconnect(); 原文：http://www.jianshu.com/p/b5c9e4c7b1e1","tags":[]},{"title":"axios 入门","date":"2017-10-12T01:00:50.000Z","path":"2017/10/12/axios-入门/","text":"axios 入门请忽略大图，不只是Vue，其他js均可用 001 Editor: Yangfan 2017-08-17Intro: 本文档参考axios的官方文档和网上的axios使用教程所写，后续还会不断完善，鄙人水平有限，还望批评指正 强烈建议查看完整文档，链接如下 英文原文档： https://github.com/mzabriskie/axios 中文文档：https://www.awesomes.cn/repo/mzabriskie/axioshttps://segmentfault.com/a/1190000008470355 什么是axios引用axios的介绍： Promise based HTTP client for the browser and node.js axios是一个基于ES6的Promise的网络请求库，是一个ajax库。 可以实现： 在浏览器里建立XHR 通过nodejs进行http请求 甚至可以实现： 转换或者拦截请求数据或响应数据 支持Promise的API 可以取消请求 自动转换JSON 可以防御XSRF攻击！ 浏览器支持也没什么问题，IE这种本时代异端都能支持到8+，这问题是不大了。（VUE支持到9+！） Chrome](https://raw.github.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png) | ![Firefox](https://raw.github.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png) | ![Safari](https://raw.github.com/alrra/browser-logos/master/src/safari/safari_48x48.png) | ![Opera](https://raw.github.com/alrra/browser-logos/master/src/opera/opera_48x48.png) | ![Edge](https://raw.github.com/alrra/browser-logos/master/src/edge/edge_48x48.png) | ![IE Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ [ Browser Matrix](https://saucelabs.com/open_sauce/build_matrix/axios.svg) 怎么用方法一 npm安装 npm下载 1npm install axios webpack之类的打包工具导入 12345678910111213141516171819202122import axios from 'axios'// orvar axios=require('axios');//===============Vue===================// Vue全局引用及使用import axios from 'axios'Vue.prototype.$http = axiosthis.$http.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 方法二 script标签引入12&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 用法及DEMO简单的demo一个简单的HTTP GET请求 12345678910111213141516171819202122232425// 法一 请求参数写到url中axios.get('http://getRes.php?id=123456&amp;name=Yangfan').then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;);// 法二 请求参数写到axios配置参数中axios.get('http://getRes.php'，&#123; params:&#123; id:123456, name:\"Yangfan\" &#125;&#125;).then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;); 一个简单的HTTP POST 请求 1234567891011axios.post('http://getRes.php',&#123; id:123456, name:\"Yangfan\"&#125;).then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;); 自定义请求配置 123456789101112131415161718192021// 配置var config=&#123; method: 'GET', // 请求方法 url: 'http://getRes.php', // 请求url headers: &#123; token: 'ftv1443qby6bdfa41t90sfvq89hg3h54u989m9imog79g4' // 请求头 &#125;, data: &#123; // 需要传递的数据 id: 123456, name: 'Yangfan' &#125;&#125;;axios(config).then(function (response) &#123; // TODO // 返回HTTP请求成功的数据&#125;).catch(function (error) &#123; // TODO // 返回HTTP请求失败的失败信息&#125;); 完整配置 参数 类型 注解 url String url是服务器链接，用来请求 method String method是发起请求时的请求方法 baseURL String baseURL如果url不是绝对地址，那么将会加在其前面。 transformRequest Function transformRequest允许请求的数据在传到服务器之前进行转化。 transformResponse Function transformResponse允许返回的数据传入then/catch之前进行处理 headers Object headers是自定义的要被发送的头信息 params Object params是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象 paramsSerializer Function paramsSerializer是一个可选的函数，是用来序列化参数 data Object data是请求提需要设置的数据 只适用于应用的’PUT’,’POST’,’PATCH’，请求方法 当没有设置transformRequest时，必须是以下其中之一的类型（不可重复？）： -string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams -仅浏览器：FormData,File,Blob -仅Node：Stream timeout Number timeout定义请求的时间，单位是毫秒。 withCredentials Boolean withCredentials表明是否跨网站访问协议， adapter Function adapter适配器，允许自定义处理请求，这会使测试更简单。 auth Object auth表明HTTP基础的认证应该被使用，并且提供证书。 这个会设置一个authorization 头（header），并且覆盖你在header设置的Authorization头信息。 responseType String responsetype表明服务器返回的数据类型，这些类型的设置应该是 ‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’ xsrfCookieName String xsrfCookieName是cookie名，用作xsrf token值 xsrfHeaderName String xsrfHeaderName 是http头（header）的名字，并且该头携带xsrf的值 onUploadProgress Function onUploadProgress允许处理上传过程的事件 onDownloadProgress Function onDownloadProgress允许处理下载过程的事件 maxContentLength Number maxContentLength 定义http返回内容的最大容量 validateStatus Function validateStatus 定义promise的resolve和reject。 http返回状态码，如果validateStatus返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。 maxRedirects Number maxRedirects定义了node.js中要重定向的最大数量。 如果设置为0，则不会重定向。 httpAgent Object httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 httpsAgent Object httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 proxy Object proxy定义服务器的主机名字和端口号。 auth表明HTTP基本认证应该跟proxy相连接，并且提供证书。 这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。 cancelToken Function cancelTaken 定义一个取消，能够用来取消请求 返回结果1234567891011121314151617&#123; // 服务器返回的数据 data: &#123;&#125;, // 服务器返回的状态码 status: 200, // 服务器返回的状态信息 statusText: 'OK', // 服务器返回的响应头信息 headers: &#123;&#125;, // `config`是提供给`axios`的请求的配置 config: &#123;&#125;&#125;","tags":[]},{"title":"[转]如何监听JS变量的变化","date":"2017-09-20T06:04:08.000Z","path":"2017/09/20/转-如何监听JS变量的变化/","text":"如何监听JS变量的变化[转]读前必看Object.defineProperty() https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty 如何监听 js 中变量的变化?我现在有这样一个需求，需要监控js的某个变量的改变，如果该变量发生变化，则触发一些事件，不能使用timeinterval之类的定时去监控的方法，不知道有比较好的解决方案么？ 这个问题问的很好。 流行的MVVM的JS库/框架都有共同的特点就是数据绑定，在数据变更后响应式的自动进行相关计算并变更DOM展现。所以这个问题也可以理解为如何实现MVVM库/框架的数据绑定。 常见的数据绑定的实现有脏值检测，基于ES5的getter和setter，以及ES已被废弃的Object.observe，和ES6中添加的Proxy。 脏值检测angular使用的就是脏值检测，原理是比较新值和旧值，当值真的发生改变时再去更改DOM，所以angular中有一个$digest。那么为什么在像ng-click这样的内置指令在触发后会自动变更呢？原理也很简单，在ng-click这样的内置指令中最后追加了$digest。 简易的实现一个脏值检测： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;two-way binding&lt;/title&gt; &lt;/head&gt; &lt;body onload=\"init()\"&gt; &lt;button ng-click=\"inc\"&gt; Increase &lt;/button&gt; &lt;button ng-click=\"reset\"&gt; Reset &lt;/button&gt; &lt;span style=\"color:red\" ng-bind=\"counter\"&gt;&lt;/span&gt; &lt;span style=\"color:blue\" ng-bind=\"counter\"&gt;&lt;/span&gt; &lt;span style=\"color:green\" ng-bind=\"counter\"&gt;&lt;/span&gt; &lt;script type=\"text/javascript\"&gt; /* 数据模型区开始 */ var counter = 0; function inc() &#123; counter++; &#125; function reset() &#123; counter = 0; &#125; /* 数据模型区结束 */ /* 绑定关系区开始 */ function init() &#123; bind(); &#125; function bind() &#123; var list = document.querySelectorAll(\"[ng-click]\"); for (var i=0; i&lt;list.length; i++) &#123; list[i].onclick = (function(index) &#123; return function() &#123; window[list[index].getAttribute(\"ng-click\")](); apply(); &#125;; &#125;)(i); &#125; &#125; function apply() &#123; var list = document.querySelectorAll(\"[ng-bind='counter']\"); for (var i=0; i&lt;list.length; i++) &#123; if (list[i].innerHTML != counter) &#123; list[i].innerHTML = counter; &#125; &#125; &#125; /* 绑定关系区结束 */ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样做的坏处是自己变更数据后，是无法自动改变DOM的，必须要想办法触发apply()，所以只能借助ng-click的包装，在ng-click中包含真实的click事件监听并追加脏值检测以判断是否要更新DOM。 另外一个坏处是如果不注意，每次脏值检测会检测大量的数据，而很多数据是没有检测的必要的，容易影响性能。 关于如何实现一个和angular一样的脏值检测，知道原理后还有很多工作要去做，以及如何优化等等。如果有兴趣可以看看民工叔曾经推荐的《Build Your Own Angular.js》，第一章Scope便讲了如何实现angular的作用域和脏值检测。对了，上面的例子也是从民工叔的博客稍加修改来的，建议最后去看下原文，链接在参考资料中。 ES5的getter与setter在ES5中新增了一个Object.defineProperty，直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 12Object.defineProperty(obj, prop, descriptor) 其接受的第三个参数可以取get和set并各自对应一个getter和setter方法： 123456789101112131415var a = &#123; zhihu:0 &#125;;Object.defineProperty(a, 'zhihu', &#123; get: function() &#123; console.log('get：' + zhihu); return zhihu; &#125;, set: function(value) &#123; zhihu = value; console.log('set:' + zhihu); &#125;&#125;);a.zhihu = 2; // set:2console.log(a.zhihu); // get：2 // 2 基于ES5的getter和setter可以说几乎完美符合了要求。为什么要说几乎呢？ 首先IE8及更低版本IE是无法使用的，而且这个特性是没有polyfill的，无法在不支持的平台实现，这也是基于ES5getter和setter的Vue.js不支持IE8及更低版本IE的原因。也许有人会提到avalon，avalon在低版本IE借助vbscript一些黑魔法实现了类似的功能。 除此之外，还有一个问题就是修改数组的length，直接用索引设置元素如items[0] = {}，以及数组的push等变异方法是无法触发setter的。如果想要解决这个问题可以参考Vue的做法，在Vue的observer/array.js中，Vue直接修改了数组的原型方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)/** * Intercept mutating methods and emit events */;[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) &#123; // cache original method var original = arrayProto[method] def(arrayMethods, method, function mutator () &#123; // avoid leaking arguments: // http://jsperf.com/closure-with-arguments var i = arguments.length var args = new Array(i) while (i--) &#123; args[i] = arguments[i] &#125; var result = original.apply(this, args) var ob = this.__ob__ var inserted switch (method) &#123; case 'push': inserted = args break case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 这样重写了原型方法，在执行数组变异方法后依然能够触发视图的更新。 但是这样还是不能解决修改数组的length和直接用索引设置元素如items[0] = {}的问题，想要解决依然可以参考Vue的做法：前一个问题可以直接用新的数组代替旧的数组；后一个问题可以为数组拓展一个$set方法，在执行修改后顺便触发视图的更新。 已被废弃的Object.observeObject.observe曾在ES7的草案中，并在提议中进展到stage2，最终依然被废弃。这里只举一个MDN上的例子： 1234567891011121314151617181920// 一个数据模型var user = &#123; id: 0, name: 'Brendan Eich', title: 'Mr.'&#125;;// 创建用户的greetingfunction updateGreeting() &#123; user.greeting = 'Hello, ' + user.title + ' ' + user.name + '!';&#125;updateGreeting();Object.observe(user, function(changes) &#123; changes.forEach(function(change) &#123; // 当name或title属性改变时, 更新greeting if (change.name === 'name' || change.name === 'title') &#123; updateGreeting(); &#125; &#125;);&#125;); 由于是已经废弃了的特性，Chrome虽然曾经支持但也已经废弃了支持，这里不再讲更多，有兴趣可以搜一搜以前的文章，这曾经是一个被看好的特性（Object.observe()带来的数据绑定变革）。当然关于它也有一些替代品Polymer/observe-js。 ES6带来的Proxy人如其名，类似HTTP中的代理： 1234var p = new Proxy(target, handler);target为目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。handler为处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。 举个例子： 1234567891011let a = new Proxy(&#123;&#125;, &#123; set: function(obj, prop, value) &#123; obj[prop] = value; if (prop === 'zhihu') &#123; console.log(\"set \" + prop + \": \" + obj[prop]); &#125; return true; &#125;&#125;);a.zhihu = 100; 当然，Proxy的能力远不止此，还可以实现代理转发等等。 但是要注意的是目前浏览器中只有Firefox18支持这个特性，而babel官方也表明不支持这个特性： Unsupported featureDue to the limitations of ES5, Proxies cannot be transpiled or polyfilled. 目前已经有babel插件可以实现，但是据说实现的比较复杂。如果是Node的话升级到目前的最新版本应该就可以使用了，上面的例子测试环境为Node v6.4.0。 原文：https://blog.daraw.cn/2016/08/17/how-to-monitor-changes-of-js-variable/","tags":[]},{"title":"shell常用命令","date":"2017-07-16T11:59:04.000Z","path":"2017/07/16/shell常用命令/","text":"shell常用命令1 ls命令：列出文件 ls -la 列出当前目录下的所有文件和文件夹 ls a* 列出当前目录下所有以a字母开头的文件 ls -l *.txt 列出当前目录下所有后缀名为txt的文件 2 cp命令：复制cp a.txt b.txt 把文件a的内容复制到b文件 cp a.txt ./test 把文件a复制到text目录下 cp -a test test2 递归的把目录test下所有文件（包括隐藏的文件）复制到新的目录 test2 3 cat命令：查看 组合文件cat a.txt 查看文件的内容 cat a.txt &gt;&gt; b.txt 把a文件的内容组合到b文件内容的末尾 cat -n a.txt 查看文件并给文件标上行号 4 touch命令：建立文件touch a.txt 建立一个名为a的txt类型文件 5 rm命令：删除文件rm -rf a.txt 强制删除文件a.txt rm -i a.txt 删除文件前会有提示是否确定删除该文件 6 mkdir命令：创建目录mkdir test 创建一个名为test的目录 7 rmdir命令：删除目录rmdir test 删除一个目录 8 echo、cat命令：添加内容echo “hello world!” &gt;&gt; a.txt 添加内容到文件a里面 cat &lt;&lt;EOF&gt;&gt; a.txt 可以添加多行语句到文件本身内容的末尾 cat &lt;&lt;EOF&gt; a.txt 添加内容到文件并覆盖到原始的内容 9 mv命令：移动 重命名文件mv a.txt b.txt 文件a重新命名为b mv a.txt ./test 把文件移动到一个目录下 10 cd命令：更换目录cd ~ 切换到用户目录 cd .. 返回到上一层目录 cd ../.. 返回到上二层目录 11 grep命令：搜索文件ls -la | grep a.txt 搜索a.txt文件 12 find命令：查找文件和目录find filename 查找当前目录下是否有该文件/目录 13 rz sz命令：上传和下载文件14 head命令：显示文件的前10行内容15 tail命令：显示文件最后10行内容","tags":[]},{"title":"高德地图 Javascript API 入门（八）","date":"2017-03-07T13:57:02.000Z","path":"2017/03/07/高德地图 Javascript API 入门（八）/","text":"高德地图 Javascript API 入门（八）点聚合插件用于地图上加载大量点标记，提高地图浏览性能。点聚合支持用户自定义点标记 加载地图123456// 加载地图var map=new AMap.Map(\"container\",&#123; resizeEnable:true, center:[116.397428, 39.90923], zoom:11&#125;); 生成点标记1234567891011// 生成点标记var markers=[];var marker=null;for (var i=0;i&lt;100;i++) &#123; marker=new AMap.Marker(&#123; position:[116.39+0.001*Math.random()*i, 39.90-0.001*Math.random()*i], icon: \"http://amappc.cn-hangzhou.oss-pub.aliyun-inc.com/lbs/static/img/marker.png\" &#125;); marker.setMap(map); markers.push(marker);&#125; 载入点聚合插件 默认样式 123map.plugin([\"AMap.MarkerClusterer\"],function () &#123; var cluster=new AMap.MarkerClusterer(map,markers);&#125;); 预览 image 自定义样式 1234567891011121314151617181920212223// 聚合样式var sts=[&#123; url:\"http://a.amap.com/lbs/static/img/1102-1.png\", size:new AMap.Size(32,32), offset:new AMap.Pixel(-16,-30), imageOffset:new AMap.Pixel(0,0)&#125;,&#123; url:\"http://a.amap.com/lbs/static/img/2.png\", size:new AMap.Size(32,32), offset:new AMap.Pixel(-16,-30)&#125;,&#123; url:\"http://lbs.amap.com/wp-content/uploads/2014/06/3.png\", size:new AMap.Size(32,32), offset:new AMap.Pixel(-16,-30), textColor:\"#f00\", textSize:30&#125;];// 载入插件map.plugin([\"AMap.MarkerClusterer\"],function () &#123; var cluster=new AMap.MarkerClusterer(map,markers,&#123; styles:sts &#125;);&#125;); 预览 image MarkerClustererOptionsMarkerClustererOptions类型说明gridSizeNumber聚合计算时网格的像素大小，默认60minClusterSizeNumber聚合的最小数量。默认值为2，即小于2个点则不能成为一个聚合maxZoomNumber最大的聚合级别，大于该级别就不进行相应的聚合。默认值为18，即小于18级的级别均进行聚合，18及以上级别不进行聚合averageCenterBoolean聚合点的图标位置是否是所有聚合内点的中心点。默认为否，即聚合点的图标位置位于聚合内的第一个点处stylesArray&lt;Object&gt;自定义聚合后的点标记图标的样式，根据数组元素顺序设置1-10,11-100,101-1000…聚合样式当用户设置聚合样式少于实际叠加的点数，未设置部分按照系统默认样式显示单个图标样式包括以下几个属性：1. {string}url：图标显示图片的url地址（必选）2. {AMap.Size}size：图标显示图片的大小（必选）3. {AMap.Pixel} offset：图标定位在地图上的位置相对于图标左上角的偏移值。默认为(0,0),不偏移（可选）4. {AMap.Pixel} imageOffset：图片相对于可视区域的偏移值，此功能的作用等同CSS中的background-position属性。默认为(0,0)，不偏移（可选）5. {String} textColor：文字的颜色，默认为”#000000”（可选）6. {Number} textSize：文字的大小，默认为10（可选）zoomOnClickBoolean点击聚合点时，是否散开，默认值为：true 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（七）","date":"2017-03-04T13:03:02.000Z","path":"2017/03/04/高德地图 Javascript API 入门（七）/","text":"高德地图 Javascript API 入门（七）热力图插件简单例子1234567891011121314151617181920212223242526// 显示地图var map=new AMap.Map(\"container\",&#123; resizeEnable:true, center:[116.397428, 39.90923], zoom:11&#125;);// 坐标点var points =[ &#123;\"lng\":116.191031,\"lat\":39.988585,\"count\":100&#125;, &#123;\"lng\":116.389275,\"lat\":39.925818,\"count\":60&#125;, &#123;\"lng\":116.287444,\"lat\":39.810742,\"count\":200&#125;, &#123;\"lng\":116.481707,\"lat\":39.940089,\"count\":30&#125;, &#123;\"lng\":116.410588,\"lat\":39.880172,\"count\":200&#125;, &#123;\"lng\":116.394816,\"lat\":39.91181,\"count\":10&#125;, &#123;\"lng\":116.416002,\"lat\":39.952917,\"count\":150&#125;];// 加载热力图插件map.plugin([\"AMap.Heatmap\"],function () &#123; var heatmap=new AMap.Heatmap(map,&#123; radius:50 &#125;); heatmap.setDataSet(&#123; data:points, max:100 &#125;);)&#125;; 预览 image 参数AMap.Heatmap 构造函数说明AMap.Heatmap(map:Map,opts:HeatmapOptions)构造一个热力图插件对象，map为要叠加热力图的地图对象，opts属性参考HeatmapOptions列表中的说明。 options HeatmapOptions类型说明radiusNumber热力图中单个点的半径，默认：30，单位：pixelgradientObject热力图的渐变区间，热力图按照设置的颜色及间隔显示热力图，例：{0.4:’rgb(0, 255, 255)’,0.65:’rgb(0, 110, 255)’,0.85:’rgb(100, 0, 255)’,1.0:’rgb(100, 0, 255)’} 其中 key 表示间隔位置，取值范围： [0,1]，value为颜色值。默认：heatmap.js标准配色方案opacityArray热力图透明度数组，取值范围[0,1]，0表示完全透明，1表示不透明，默认：[0,1]zoomsArray支持的缩放级别范围，取值范围[3-18]，默认：[3,18] 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（六）","date":"2017-02-28T10:03:02.000Z","path":"2017/02/28/高德地图 Javascript API 入门（六）/","text":"高德地图 Javascript API 入门（六）出行规划公交路径公交换乘服务，提供起、终点公交路线规划服务，整合步行方式 初始化 1234567891011// 加载公交线路插件AMap.service(\"AMap.Transfer\",function () &#123; // 实例化Transfer var transfer=new AMap.Transfer(&#123; city:\"北京\", // 必须值，搭乘公交所在城市 map:map, // 可选值，搜索结果的标注、线路等均会自动添加到此地图上 panel:\"panel\", // 可选值，显示搜索列表的容器, extensions:\"all\", // 可选值，详细信息 poliy:AMap.TransferPolicy.LEAST_TIME // 驾驶策略：最省时模式 &#125;);&#125;); 按关键字搜索 1234// 关键字搜索transfer.search([&#123;keyword:\"北京西站\"&#125;,&#123;keyword:\"天安门\"&#125;],function (status,result) &#123; window.top.data=result;&#125;); 按坐标搜索 1234// 按坐标搜索transfer.search([116.379028, 39.865042], [116.427281, 39.903719],function (status,result) &#123; window.top.data=result;&#125;); 预览 驾车路径驾车路线规划服务，提供起、终点坐标的驾车导航路线查询功能 初始化 12345678910111213141516// 加载驾车路径插件AMap.service(\"AMap.Driving\",function () &#123; // 实例化Driving var driving=new AMap.Driving(&#123; map:map, // 用来承载 显示路径 panel:\"panel\", // 显示搜索列表的容器 extensions:\"all\", // 详细信息 policy:AMap.DrivingPolicy.REAL_TRAFFIC, // 驾驶策略：合理交通 showTraffic:true, // 是否显示路况 province:\"晋\", // 判断限行 number:\"A88888\", // 判断限行 hideMarkers:false, // 隐藏起点、终点的点标注 isOutline:true, // 是否显示线路的边框 outlineColor:\"#f00\" // 边框颜色 &#125;);&#125;); 按关键字搜索 1234// 按关键字搜索 driving.search([&#123;keyword:\"北京西站\",city:\"北京\"&#125;,&#123;keyword:\"天安门\",city:\"北京\"&#125;],function (status,result) &#123; window.top.data=result; &#125;); 按坐标搜索 1234// 按坐标搜索driving.search([116.379028, 39.865042], [116.427281, 39.903719],function (status,result) &#123; window.top.data=result; &#125;); 预览 image 限行结果0 代表限行已规避或未限行，即该路线没有限行路段1 代表限行无法规避，即该线路有限行路段 image 步行路径步行导航服务，提供起、终点步行路线规划服务 初始化 1234567// 加载步行路径插件AMap.service(\"AMap.Walking\",function () &#123; var walking=new AMap.Walking(&#123; map:map, panel:\"panel\" &#125;);&#125;); 按关键字搜索 123walking.search([&#123;keyword:\"方恒国际中心A座\"&#125;,&#123;keyword:\"望京站\"&#125;],function (status,result) &#123; window.top.data=result;&#125;); 按坐标搜索 123walking.search([116.379028, 39.865042],[116.427281, 39.903719],function (status,result) &#123; window.top.data=result;&#125;); 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（五）","date":"2017-02-26T14:03:02.000Z","path":"2017/02/26/高德地图 Javascript API 入门（五）/","text":"高德地图 Javascript API 入门（五）搜索服务搜索服务名称说明是否插件AMap.Autocomplete输入提示，根据输入关键字提示匹配信息是AMap.PlaceSearch地点搜索服务插件，提供某一特定地区的位置查询服务是AMap.PlaceSearchLayer麻点图插件，提供海量搜索结果的辅助显示功能是AMap.DistrictSearch行政区查询服务，提供行政区相关信息是AMap.LineSearch公交路线服务，提供公交路线相关信息查询服务是AMap.StationSearch公交站点查询服务，提供途经公交线路、站点经纬度等信息是 地点搜索插件 AMap.PlaceSearch 创建地点查询类的实例 123456789101112// 创建地点查询类的实例AMap.service(\"AMap.PlaceSearch\",function () &#123; var s1=new AMap.PlaceSearch(&#123; city:\"北京市\", // 搜索范围的城市 type:\"风景名胜\", // 搜索类型 map:map, // 可选，AMap示例 panel:\"result\", // 可选，结果列表的HTML容器id或容器元素 pageSize:5, // 结果，单页展示结果数 pageIndex:2, // 结果，页码 extensions:\"all\" // 信息，默认值 \"base\", 详细信息 \"all\" &#125;);&#125;); 根据关键字搜索 1234// 关键字搜索s1.search(\"八达岭\",function (status,result) &#123; console.log(result);&#125;); 预览 image 根据中心点经纬度、半径以及关键字进行周边查询（周边搜索） 1234// 周边搜索s1.searchNearBy(\"餐饮\",[116.403322, 39.920255],1000,function (status,result) &#123; console.log(result); &#125;); 预览 image 根据范围和关键词进行范围查询 123var lnglat1=new AMap.LngLat( 116.403322, 39.920255);var lnglat2=new AMap.LngLat( 116.389846, 39.891365);s1.searchInBounds('酒店',new AMap.Bounds(lnglat1,lnglat2)); 预览 image 根据POIID 查询POI详细信息 POIID是返回数据（JSON）的一个 id 值 image 获取POI的详细信息 1234s1.getDetails(\"B000A82RP2\",function (status,result) &#123; console.log(result.poiList.pois[0].name); window.top.data=result.poiList.pois[0]; &#125;); 预览 image 公交线路搜索插件 AMap.LineSearch 创建公交线路查询类的实例 123456AMap.service(\"AMap.LineSearch\",function () &#123; var lineSearch=new AMap.LineSearch(&#123; city:\"太原\", extensions:\"all\" &#125;); &#125;); 按关键字查询公交线路 123456lineSearch.search(\"901\",function (status,result) &#123; if (status===\"complete\" &amp;&amp; result.info===\"OK\") &#123; console.log(result); window.top.data=result; &#125; &#125;); 预览 image 按id查询公交线路 123456lineSearch.searchById(\"140100010458\",function (status,result) &#123; if (status===\"complete\" &amp;&amp; result.info===\"OK\") &#123; console.log(result); window.top.data=result; &#125; &#125;); 预览 image LineInfo 对象 基本信息 属性类型说明idString公交线路id，该id是唯一标识nameString公交线路名称pathArray.&lt;LngLat&gt;公交线路经纬度citycodeString公交线路所在城市的城市编码typeString公交类型列表typeString公交类型列表start_stopString首发站end_stopString终点站 详细信息 属性类型说明stimeString首班车时间etimeString末班车时间basic_priceString起步票价，单位：元total_priceString全程票价，单位：元via_stopsString途径站，包括首发站和终点站distanceNumber全程距离，单位：千米boundsBounds此公交路线的地理范围companyString所属公交公司 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（四）","date":"2017-02-22T11:03:02.000Z","path":"2017/02/22/高德地图 Javascript API 入门（四）/","text":"高德地图 Javascript API 入门（四）地图覆盖物覆盖物类名说明是否插件AMap.Marker点标记否AMap.Icon覆盖物&gt;点标记&gt;复杂点标记对象，对普通点标记Marker 的扩展否AMap.Polyline覆盖物&gt;折线否AMap.Polygon覆盖物&gt;多边形否AMap.Circle覆盖物&gt;圆否AMap.GroundImage图片覆盖物否AMap.ContextMenu地图右键菜单否 点标记JS 1234var marker=new AMap.Marker(&#123; map:map, position:new AMap.LngLat(112.736465,37.696495)&#125;); 预览 iamge 自定义点标记 JS 12345678910111213141516171819var marker=new AMap.Marker(&#123; map:map, position:new AMap.LngLat(112.736465,37.696495), icon:new AMap.Icon(&#123; image:\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2803620233,1906638381&amp;fm=23&amp;gp=0.jpg\", size:[72,72], imageSize:[36,36] &#125;), draggable:true, raiseOnDrag:true, shape:new AMap.MarkerShape(&#123; type:\"circle\", coords:[112.736465,37.696495,100] &#125;), label:&#123; content:\"label\", offset:new AMap.Pixel(0,-36) &#125;&#125;); 预览 image 多边形JS 12345678910var lineArr=[ [112.49157,37.897392], [112.602806,37.898747], [112.608643,37.797355], [112.49775,37.79627]];var polygon=new AMap.Polygon(&#123; map:map, path:lineArr&#125;); 预览 image 右键菜单JS 1234567891011121314151617181920var contextmenu=new AMap.ContextMenu();var pos=[];// 添加右键菜单内容项contextmenu.addItem(\"放大\",function () &#123; map.zoomIn();&#125;,0);contextmenu.addItem(\"缩小\",function () &#123; map.zoomOut();&#125;,1);contextmenu.addItem(\"添加点标记\",function () &#123; var marker=new AMap.Marker(&#123; map:map, position:pos &#125;);&#125;,2);// 监听鼠标右击事件map.on(\"rightclick\",function (e) &#123; contextmenu.open(map,e.lnglat); pos=e.lnglat;&#125;); 预览 image 信息窗体信息窗体JS 123456789var infowindow=new AMap.InfoWindow(&#123; isCustom:false, content:\"&lt;h3&gt;Hello,Yuanping&lt;/h3&gt;\", offset:new AMap.Pixel(0,-36), showShadow:true, closeWhenClickMap:true, autoMove:true&#125;);infowindow.open(map,new AMap.LngLat(112.736465,38.696495)); 预览 image 小练习鼠标划过山西大剧院时，弹出信息窗体JS 123456789101112131415161718192021222324252627282930313233343536373839404142// 坐标var lineArr=[ [112.532802,37.808395], [112.533049,37.808395], [112.533124,37.808476], [112.533521,37.808459], [112.533558,37.808391], [112.533832,37.808391], [112.533848,37.80792], [112.534159,37.807959], [112.534159,37.80748], [112.533826,37.807514], [112.533832,37.807179], [112.533966,37.806848], [112.533376,37.806683], [112.533054,37.806687], [112.532684,37.806878], [112.53278,37.807191], [112.532796,37.80745], [112.532013,37.807285], [112.532019,37.808213], [112.532796,37.808018], [112.532818,37.808412]];// 实例化Polygon类var polygon=new AMap.Polygon(&#123; map:map, path:lineArr&#125;);// 适应窗口map.setFitView();// 实例化信息窗体类var infowindow=new AMap.InfoWindow(&#123; content:\"&lt;h3&gt;太原市&lt;/h3&gt;&lt;p&gt;山西大剧院&lt;/p&gt;\", closeWhenClickMap:true&#125;);// 监听鼠标移入、移除事件polygon.on(\"mouseover\",function (e) &#123; infowindow.open(map,map.getCenter());&#125;).on(\"mouseout\",function () &#123; infowindow.close();&#125;); 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（三）","date":"2017-02-22T04:52:44.000Z","path":"2017/02/22/高德地图 Javascript API 入门（三）/","text":"高德地图 Javascript API 入门（三）距离测量插件区别虽然鼠标工具插件也提供距离量测功能，但是距离量测插件，提供更为丰富的样式设置功能。 加载插件JS 1234map.plugin([\"AMap.RangingTool\"],function () &#123; var rangingTool=new AMap.RangingTool(map); rangingTool.turnOn(); // 开启量测功能&#125;); 预览 image 样式设置RangingToolOptions类型说明startMarkerOptionsObject设置量测起始点标记属性对象，包括点标记样式、大小等，参考 &nbsp;&nbsp;MarkerOptions &nbsp;列表midMarkerOptionsObject设置量测中间点标记属性对象，包括点标记样式、大小等，参考 &nbsp;MarkerOptions &nbsp;列表endMarkerOptionsObject设置量测结束点标记属性对象，包括点标记样式、大小等，参考 &nbsp;MarkerOptions &nbsp;列表lineOptionsObject设置距离量测线的属性对象，包括线样式、颜色等，参考 &nbsp;PolylineOptions 列表tmpLineOptionsObject设置距离量测过程中临时量测线的属性对象，包括线样式、颜色等，参考 &nbsp;PolylineOptions &nbsp;列表startLabelTextString设置量测起始点标签的文字内容，默认为“起点”midLabelTextString设置量测中间点处标签的文字内容，默认为当前量测结果值endLabelTextString设置量测结束点处标签的文字内容，默认为当前量测结果值startLabelOffsetPixel&nbsp;设置量测起始点标签的偏移量。默认值：Pixel(-6, 6)midLabelOffsetPixel&nbsp;设置量测中间点标签的偏移量。默认值：Pixel(-6, 6)endLabelOffsetPixel&nbsp;设置量测结束点标签的偏移量。默认值：Pixel(-6, 6) 示例改变标签文字JS 12345678map.plugin([\"AMap.RangingTool\"],function () &#123; var rangingTool=new AMap.RangingTool(map,&#123; startLabelText:\"START\", midLabelText:\"MID\", endLabelText:\"END\" &#125;); rangingTool.turnOn();&#125;); 预览 image 改变线条样式JS 1234567891011121314map.plugin([\"AMap.RangingTool\"],function () &#123; var rangingTool=new AMap.RangingTool(map,&#123; lineOptions:&#123; strokeColor:\"#ff3300\", strokeStyle:\"dashed\", strokeWeight:10, strokeOpacity:0.5, isOutline:true, outlineColor:\"#009933\", showDir:true &#125; &#125;); rangingTool.turnOn();&#125;); 预览 image 小练习绘制太原市区的大概范围JS 1234567891011121314151617181920212223242526// 用坐标拾取器获得坐标var lineArr=[ [112.490931,37.898793], [112.553588,37.898793], [112.603026,37.899877], [112.605086,37.855028], [112.605601,37.831169], [112.610236,37.824661], [112.610236,37.798487], [112.602683,37.793739], [112.499171,37.793739], [112.495051,37.794553], [112.500544,37.830762], [112.500716,37.843099], [112.48973,37.847301], [112.489901,37.896897], [112.492476,37.8992]];// 实例化一个Polyline类var polyline=new AMap.Polyline(&#123; path:lineArr, strokeColor:\"#ff2200\", strokeWeight:5&#125;);// 添加到地图中polyline.setMap(map); 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（二）","date":"2017-02-21T05:53:12.000Z","path":"2017/02/21/高德地图 Javascript API 入门（二）/","text":"高德地图 Javascript API 入门（二）鼠标工具插件测量距离JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.rule();&#125;); 预览 image 测量面积JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.measureArea();&#125;); 预览 image 绘制点标注JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.marker();&#125;); 预览 image 绘制折线JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.polyline();&#125;); 预览 image 绘制多边形JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.polygon();&#125;); 预览 image 绘制矩形JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.rectangle();&#125;); 预览 image 绘制圆JS 1234map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.circle();&#125;); 预览 image 全部功能方法返回值说明marker( options：MarkerOptions)&nbsp;开启鼠标画点标注模式。鼠标在地图上单击绘制点标注，标注样式参考MarkerOptions设置polyline( options：PolylineOptions)开启鼠标画折线模式。鼠标在地图上点击绘制折线，鼠标左键双击或右键单击结束绘制，折线样式参考PolylineOptions设置polygon( options：PolygonOptions)开启鼠标画多边形模式。鼠标在地图上单击开始绘制多边形，鼠标左键双击或右键单击结束当前多边形的绘制，多边形样式参考PolygonOptions设置rectangle( options：PolygonOptions)开启鼠标画矩形模式。鼠标在地图上拉框即可绘制相应的矩形。矩形样式参考PolygonOptions设置circle( options：CircleOptions)开启鼠标画圆模式。鼠标在地图上拖动绘制相应的圆形。圆形样式参考CircleOptions设置rule( options：PolylineOptions)开启距离量测模式。鼠标在地图上单击绘制量测节点，并计算显示两两节点之间的距离，鼠标左键双击或右键单击结束当前量测操作。量测线样式参考 PolylineOptions 设置注：不能同时使用rule方法和RangTool插件进行距离量测measureArea( options：PolygonOptions)开启面积量测模式。鼠标在地图上单击绘制量测区域，鼠标左键双击或右键单击结束当前量测操作，并显示本次量测结果。量测面样式参考PolygonOptions设置rectZoomIn( options：PolygonOptions)开启鼠标拉框放大模式。鼠标可在地图上拉框放大地图。矩形框样式参考PolygonOptions设置rectZoomOut( options：PolygonOptions)开启鼠标拉框缩小模式。鼠标可在地图上拉框缩小地图。矩形框样式参考PolygonOptions设置close( Boolean)关闭当前鼠标操作。参数arg设为true时，鼠标操作关闭的同时清除地图上绘制的所有覆盖物对象；设为false时，保留所绘制的覆盖物对象。默认为false 自定义覆盖物样式以折线为例 Polyline JS 123456789map.plugin([\"AMap.MouseTool\"],function () &#123; var mouseTool=new AMap.MouseTool(map); mouseTool.polyline(&#123; strokeColor:\"#f50\", // 线条颜色，十六进制 strokeOpacity:0.5, // 线条透明度 strokeWeight:10, // 线条宽度 strokeStyle:\"dashed\" // 线条样式 solid || dashed &#125;);&#125;); 更多详细参数参考 http://lbs.amap.com/api/javascript-api/reference/overlay#PolylineOptions 预览 image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"高德地图 Javascript API 入门（一）","date":"2017-02-20T11:32:00.000Z","path":"2017/02/20/高德地图 Javascript API 入门（一）/","text":"高德地图 Javascript API 入门（一）准备工作首先注册个开发者账号 image 然后创建应用，获取Key image 新建HTML文件，在body标签中引入如下代码（把你的Key值填入即可）HTML 1&lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值\"&gt;&lt;/script&gt; 创建设置地图容器HTML 1&lt;div id=\"container\"&gt;&lt;/div&gt; CSS 1#container &#123;width:300px; height: 180px; &#125; 地图初始化创建地图JS 1var map = new AMap.Map('container'); 设置地图参数可以通过以下设置JS 1234var map = new AMap.Map('container',&#123; zoom: 12, center: [112.549248,37.852135]&#125;); 也可通过map对象的方法设置 JS 123var map = new AMap.Map('container');map.setZoom(12);map.setCenter([112.549248,37.852135]); 预览 高德地图 个性化地图改变地图样式目前支持五种地图配色模版 地图类型列表 名称说明normal默认样式dark深色样式blue_night夜空蓝样式fresh浅色样式lightosm清新风格样式 可以这样设置JS 12345var map = new AMap.Map('container', &#123; resizeEnable: true, mapStyle:'fresh', center: [116.408075, 39.950187] &#125;); 也可以这样设置JS 1map.setMapStyle(\"fresh\"); 预览 image 显示指定地图内容（地图要素）名称说明bg背景地图point兴趣点road道路building建筑 JS 12map.setFeatures(\"road\");//单一种类要素显示map.setFeatures(['road','point'])//多个种类要素显示 预览（只显示道路要素的地图） image 地图控件JavaScript API提供了工具条、比例尺、定位、鹰眼、基本图层切换等常用的控件 名称类名简介工具条ToolBar集成了缩放、平移、定位等功能按钮在内的组合控件比例尺Scale展示地图在当前层级和纬度下的比例尺定位Geolocation用来获取和展示用户主机所在的经纬度位置鹰眼OverView在地图右下角显示地图的缩略图类别切换MapType实现默认图层与卫星图、实施交通图层之间切换的控 添加控件 JS 123map.plugin([\"AMap.ToolBar\"],function () &#123; map.addControl(new AMap.ToolBar()); // 工具条控件&#125;); （其他控件添加方式同上） 预览（带有工具条控件的地图） image 参考来源：http://lbs.amap.com/作者：Yangfan","tags":[{"name":"JS","slug":"JS","permalink":"http://yangfan.site/tags/JS/"},{"name":"GIS","slug":"GIS","permalink":"http://yangfan.site/tags/GIS/"},{"name":"API","slug":"API","permalink":"http://yangfan.site/tags/API/"}]},{"title":"HTML+CSS+JAVASCRIPT 网易云音乐播放器","date":"2017-02-18T12:15:55.000Z","path":"2017/02/18/网易云音乐播放器/","text":"HTML+CSS+JAVASCRIPT 高仿低配网页版网易云音乐播放器 app-poster 前言没有使用任何框架，只是想用最简单纯js的代码实现下 前台: Javascript+jQuery 后台: php/nodejs（php是参考网上的例子写的，nodejs代码是在php的基础上重新写的） 还有她的姊妹篇（网易云音乐移动端），请查看这里 https://github.com/Yangfan2016/cloud-music-mobile#cloud-music-mobile 写在前头的话鄙人野生前端一只，gis专业，自学前端已经一年多了，为什么要写个音乐播放器呢？原因有两个： 本人是网易云音乐的重度用户，近乎疯狂 自学了前端这么久了，也是想检验下自己的成果吧 本播放器要干什么呢 简单的 播放 暂停 那当然不能少 切换歌曲，上一首 、 下一首 也得有 进度条 ，这个有点复杂，本来想用 input[range] 写，但是样式不好改，自己用多个div代替吧 进度条都有了，音量调节 不能少吧，毕竟他俩UI样式差不多，照猫画虎呗 再加一个 静音功能 ，省的音乐太大声，邻居找茬哦(⊙o⊙) 本播放器还能干什么呢 歌词滚动 有木有 搜索单曲 指定歌单播放 这个需要知道歌单的 id 不是很好找，（得上网易云音乐官网登录自己的账号，找到歌单，点进去，抬头看URL 里最后的 id 参数）暂时用的是“我喜欢的音乐”（歌单）的id music-163 那闲话不多说，开整吧（原谅一个理科生的表达能力）我模仿的是网易云音乐的PC端，所用到的技术都是前端的基本技术 HTML、CSS、JAVASCRIPT由于我是自学的，没有那么多规矩，我这个人看到是我感兴趣的，我立马就会去做，这个播放器也不例外。 首先先的将它“画”出来（HTML+CSS） 我仔细看了下网易云音乐PC端的布局，大致分为四部分，四个模块 顶部菜单（顶部导航，叫什么名无所谓了） 底部播放条 这是播放器的核心 主体内容在右边 歌单的详细信息和歌曲列表 左侧是导航和歌单组 左下角还有一个小窗，显示正在播放歌曲的简要信息，点击小窗 展开一个歌曲详情页 无图不真相 pc-music pc-music 然后呢，写页面逻辑JavaScript 播放器 播放器的控制按钮播放(暂停)按钮，这个可以通过play()和pause()方法实现 进度条这个通过监听timeupdate事件，实施更新当前播放位置，通过监听鼠标移动事件，改变进度条的长度 静音按钮，可以通过audio.muted=true实现 初始化歌单列表网易云音乐获取歌单的APIhttp://music.163.com/api/playlist/detail?id=[id] id 歌单id 因为涉及到跨域问题。暂时我前台这边又没有办法跨域，所以参考了网上的代码，写个PHP做代理 （2018-09-14更新：现在代码已改为Nodejs做代理服务），这样就不存在跨域问题了。获取到歌单数据后，重新渲染下DOM 搜索歌曲网易云音乐获取歌曲的APIhttp://s.music.163.com/search/get?s=[songname]&amp;type=1&amp;limit=10 s 搜索内容 type 搜索类型 limit 搜索返回结果数 歌曲详情页主要是歌词和歌词滚动 网易云音乐获取歌词APIhttp://music.163.com/api/song/lyric?os=pc&amp;id=[id] id 歌曲id 歌词滚动，先把获取到的歌词数据分割成时间点和歌词两部分，将这两部分存入dataset中，通过监听timeupdate事件，判断和当前播放时间相近的歌词，记录它的getBoundingClient()的top值，将滚动条设置到指定位置 例如：ele.srcollTop=100; 先写到这里吧总结能力太差了，原谅理科生的无奈 附录完整源码，点击查看后台代码，点击查看 此文源自我的博客 大佬，给个start呗^_^","tags":[{"name":"前端","slug":"前端","permalink":"http://yangfan.site/tags/前端/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"http://yangfan.site/tags/音乐播放器/"}]},{"title":"教你快速搭建个人博客","date":"2017-02-03T12:15:55.000Z","path":"2017/02/03/教你快速搭建个人博客/","text":"基于HEXO博客框架和Github搭建个人博客简单教程Author: YangfanTime: 2017-02-03 准备工作 配置环境 安装Node.js安装Git注册GitHub Hexo 部分 Hexo简介Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 hexo Hexo安装方法参考官网中文文档,只需要一条命令即可自动安装hexo框架。$ npm install -g hexo-cli #使用 npm 安装 Hexo 初始化创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：hexo init 生成静态页面继续再Blog目录下执行如下命令，生成静态页面hexo generate （或者 hexo g） 本地启动启动本地服务，进行文章预览调试，命令：hexo server 本地测试浏览器输入 http://localhost:4000 Github 部分 注册githubGithub 新建仓库建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!! 本地_config.yml文配置件，建立关联我们需要_config.yml文件，来建立关联(注意冒号后面要有空格) 12345deploy: type: git repository: https://github.com/leopardpan/ leopardpan.github.io.git branch: master 部署 执行如下命令才能使用git部署npm install hexo-deployer-git --save(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。) 执行配置命令：hexo deploy然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了 发文章 每次部署的步骤，可按以下三步来进行。 1234hexo clean hexo generate hexo deploy 一些常用命令： 12345678hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 参考： http://www.jianshu.com/p/465830080ea9 http://www.chinaz.com/web/2016/0105/491998.shtml","tags":[{"name":"博客","slug":"博客","permalink":"http://yangfan.site/tags/博客/"},{"name":"建站","slug":"建站","permalink":"http://yangfan.site/tags/建站/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yangfan.site/tags/Hexo/"}]}]